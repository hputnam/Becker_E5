---
title: "WGBS Markdown"
author: "daniellembecker"
date: "3/17/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Molecular Underpinnings Chronic Nutrient Enrichment Project

## WGBS Gene Ontology (GO) Enrichment Analysis
## Previous steps for DNA methylation include WGBS workflow in Bioinformatics>WGBS>WGBS workflow 

## Load Libraries

```{r message = FALSE, warning = FALSE}
library(plotrix) 
library(ggplot2)
library(gridExtra)
library(factoextra)
library(seacarb) 
library(dplyr)
library(pheatmap)
library(tidyverse)
library(genefilter)
library(base)
library("DESeq2")
library(cowplot)
if ("lsmeans" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('lsmeans') 
library(lsmeans)
if ("ontologyIndex" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('ontologyIndex') 
library(ontologyIndex)
if ("ontologySimilarity" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('ontologySimilarity')
library(ontologySimilarity)
library(data.table)
library(RColorBrewer)
if ("colorRamps" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('colorRamps')
library(colorRamps)
if ("limma" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('limma')
# Load the package
library(limma)
library(GSEABase)
library(here)
library(lme4)
library(vegan)
library(goseq)
library(ggpubr)
library(patchwork)
library(rstatix)
library(stringr)
library(readr)
library(png)
library(grid)
library(cowplot)
```

#Downloaded all final .bed files for and 10x from andromeda to desktop: scp -r danielle_becker@andromeda.uri.edu:/data/putnamlab/dbecks/Becker_E5/WGBS_Becker_E5/Becker_WGBS/CovtoCyto/*_enrichment.bed /Users/Danielle/Desktop/Putnam_Lab/Becker_E5/RAnalysis/Data/WGBS

###Samples E7, E8, AND C28 had low data coverage, not moving forward with these samples in statistical steps

Methylation Analysis
## Loading genomic and annotation
```{r}
#load sample information
sample.info <- read.csv("RAnalysis/Data/metadata.WGBS.csv", header=T, sep=",", na.string="NA", stringsAsFactors = F) #read in info
#samp <- sample.info$Sample.ID # set sample info
#samp <- gsub("[_]", "-", samp) #remove extra characters

#load genes gff 
Genes <- read.csv("RAnalysis/Output/rename_structure_gff3.csv") #read in data fill
Genes <- Genes[,c(10,2,5,6, 11)] #select desired columns only
colnames(Genes) <- c("gene","scaffold", "start", "stop", "length") #rename columns
Genes$gene <-  gsub("_","_gene_", Genes$gene) #add _gene_g#

#Load annotation file
Annot <- read.csv("Functional_Annotation/pver_annot_full.csv", row.names = 1)
colnames(Annot)[1] <- "gene"

#edit gene ID to match GFF3
Annot$gene <-  gsub("\\..*","",Annot$gene) #remove the all after . "t#" number after the dash
Annot$gene <-  gsub("_","_gene_",Annot$gene) #add _gene_g#

#load all gene GO IDs organized and split
Gene.GO.IDs <- read.csv("Functional_Annotation/pver_GOterms_interprot_swissprot_blast_trembl_20211203.csv", row.names = 1)
colnames(Gene.GO.IDs) <- c("gene", "GO.IDs") #rename columns

#edit gene ID to match GFF3
Gene.GO.IDs$gene <-  gsub("\\..*","",Gene.GO.IDs$gene) #remove the all after . "t#" number after the dash
Gene.GO.IDs$gene <-  gsub("_","_gene_",Gene.GO.IDs$gene) #add _gene_g#
Gene.GO.IDs$GO.IDs <- as.character(Gene.GO.IDs$GO.IDs) #make IDs into characters
GO.IDs <-unique(Gene.GO.IDs$GO.IDs) #removes duplicates from columns, compiles both lists to get all GO terms without duplicates
```

#Load filtered methylation counts 10x (only need to run initially, redone on 20240810, commented out as we filtered SNPs from the output in the next section)
```{r}
# # #Merge final .bed files at 10x coverage
#  meth.data.10x <- list.files(path = "Bioinformatics/Data/10x_methcounts/", pattern = ".bed$", full.names=TRUE) %>%
#    purrr::set_names(.) %>% 
#    map_dfr(read.csv,.id="WGS.lib.ID", header=FALSE, sep="\t", na.string="NA", stringsAsFactors = FALSE) %>% 
#    dplyr::select(-c(V3,V7:V14)) %>%
#    group_by(WGS.lib.ID)
# 
#  colnames(meth.data.10x) <- c("WGBS.lib.ID", "scaffold", "position","per.meth","meth","unmeth","gene") #change column names
#  meth.data.10x$gene <- gsub(";.*","",meth.data.10x$gene) #remove extra characters
#  meth.data.10x$gene <- gsub("ID=","",meth.data.10x$gene) #remove extra characters
#  meth.data.10x$WGBS.lib.ID <- gsub("Bioinformatics/Data/10x_methcounts//","",meth.data.10x$WGBS.lib.ID) #remove extra characters
#  meth.data.10x$WGBS.lib.ID <- gsub("_.*","",meth.data.10x$WGBS.lib.ID) #remove extra characters 
#  unique_lib_ids <- unique(meth.data.10x$WGBS.lib.ID) # check all unique IDs included
#  #meth.data.10x$WGBS.lib.ID <- gsub("-","_",meth.data.10x$WGBS.lib.ID) #remove extra characters
#  #meth.data.10x$WGBS.lib.ID <- gsub("/","",meth.data.10x$WGBS.lib.ID) #remove extra characters (backslash from sample.ID name)
#  
#  #combine sample info and 10x coverage megafile
#  MD.10x <- merge(meth.data.10x, sample.info, by="WGBS.lib.ID")
#  unique_fragment_ids <- unique(MD.10x$fragment.ID) # check all unique IDs included
#  
# # Filter WGBS libraries 2, 16, and 19 that had low coverage
# # Define libraries with low coverage
# low_coverage_libraries <- c(2, 16, 19)
# 
# # Filter out these libraries from the combined dataset
# MD.10x_filtered <- MD.10x[!MD.10x$WGBS.lib.ID %in% low_coverage_libraries, ]
# unique_library_ids <- unique(MD.10x_filtered$WGBS.lib.ID)
# print(unique_library_ids)
 
# #save sample info and percent methylation
# saveRDS(MD.10x_filtered, "RAnalysis/Output/sample_all_methylated_data_10x.Rdata")

```

# Filter out any SNPs that could impact our methylation data and use updated and filtered data frame for next steps
```{r}
# Filtering SNPs found from BS-SNper, following this workflow: https://github.com/daniellembecker/DanielleBecker_Lab_Notebook/blob/master/_posts/2024-02-12-Testing-BS-SNPer-Molec-Underpinnings-WGBS.md and this script: https://github.com/hputnam/Becker_E5/blob/master/RAnalysis/Scripts/WGBS/BS-SNPer.filter.Rmd

# Use the new MD.10x file that has now been filtered for SNPs
MD.10x <- readRDS("../../../Downloads/filtered_bed_SNP_file (2).Rdata") #read in info

head(MD.10x)

```


# Testing for Differentially Methylated Genes at 10X coverage
```{r}
# Comparison of enriched vs control nutrient treatments
# At 10x coverage
# Binomial GLM to test for differentially methylated genes
sub_meth_table.10x  <- MD.10x
sub_meth_table.10x$group <- paste0(sub_meth_table.10x$Sample.ID, sub_meth_table.10x$gene)

# Filter genes with >=5 methylated positions
min.filt.10x <- dplyr::count(sub_meth_table.10x, vars = c(group))
newdata.10x <- min.filt.10x[min.filt.10x$n >= 5, ]
sub_meth_table.10x <- sub_meth_table.10x[sub_meth_table.10x$group %in% newdata.10x$vars,]

# Initialize results dataframe
results.10x <- data.frame()
gs.10x <- unique(sub_meth_table.10x$gene)

# Calculate differentially methylated genes
#first subset the unique dataframes and second run the GLMs
#purr package function called map, much cleaner for for loops (how to loop over a model in the tidyverse, can have a tidy output for your anova) computational time is faster with purr and it is cleaner
for(i in 1:length(sub_meth_table.10x$gene)){
  
  #subset the dataframe gene by gene
  sub_meth_table.10x1 <- subset(sub_meth_table.10x, gene ==gs.10x[i])
  
  # fit glm position model
  #think about this as just a logistic regression, linear model on binomial distribution is binomial distribution, just adding a random effect for block. P-values based off of maximum likelihood approach, not gonna be like an anova table. 
  fit <- glm(matrix(c(meth, unmeth), ncol=2) ~ treatment, 
             data=sub_meth_table.10x1, family=binomial)
  a <- anova(fit, test="Chisq")
  
  # capture summary stats to data frame
  df <- data.frame(gene = sub_meth_table.10x1[1,7],
                   pval.treatment = a$`Pr(>Chi)`[2],
                   #pval.position = a$`Pr(>Chi)`[3], #uncomment if you want to include position of CpG within a gene
                   #pval.treatment_x_position = a$`Pr(>Chi)`[4], #uncomment if you want to include position of CpG within a gene interaction with treatment
                   stringsAsFactors = F)
  
  # bind rows of temporary data frame to the results data frame
  results.10x <- rbind(results.10x, df)
  
}


# write dataframe
write.csv(results.10x, "RAnalysis/Output/meth.results.10x.csv")
#An error will be generated here for contrasts. 
#This potential for contrasts (interactions) is included in the case one wants to examine the role of position of CpG within a gene
#Continuing the analysis from results line will generate the results in the absence of the contrast (interaction).

results.10x <- read.csv("RAnalysis/Output/meth.results.10x.csv", row.names = 1)
results.10x[is.na(results.10x)] <- 0
results.10x$adj.pval.treatment <- p.adjust(results.10x$pval.treatment, method='BH') #BH is a less conservative Benjamini & Hochberg (1995) correction in which p-values are multiplied by the number of comparisons

#results$adj.pval.position <- p.adjust(results$pval.position, method='BH') #uncomment if you want to include position of CpG within a gene
#result $adj.pval.treatment_x_position <- p.adjust(results$pval.treatment_x_position, method='BH') #uncomment if you want to include position of CpG within a gene interaction with treatment

# Identifying DMG with significant main effect 
DMG.sig.10x <- results.10x
DMG.sig.10x <- DMG.sig.10x[order(DMG.sig.10x$adj.pval.treatment),]
DMG.sig.10x <- DMG.sig.10x[which(DMG.sig.10x$adj.pval.treatment<0.05), ]
sum(DMG.sig.10x$adj.pval.treatment < 0.05, na.rm=TRUE) #How many adjusted p-values were less than 0.05?

#376

# Annotation of DMG under between treatments 
DMG.sig.annot.10x <- left_join(DMG.sig.10x , Annot, by="gene")
#DMG.sig.annot <- DMG.sig.annot[!duplicated(DMG.sig.annot$gene),]
write.table(DMG.sig.annot.10x, 'RAnalysis/Output/Treatment_sig_annot.10x.tsv', sep='\t', row.names=FALSE)

# Sanity check to make sure DMGs are calculated correctly
# Select data from MD.10x with significant DMGs
methylation_data <- MD.10x %>%
  filter(gene %in% DMG.sig.annot.10x$gene)

# Calculate relative change to confirm differential methylation calculated correctly 
# Calculate mean methylation per treatment
mean_meth <- methylation_data %>%
  group_by(gene, treatment) %>%
  summarize(mean_per_meth = mean(per.meth), .groups = 'drop')

# Widen data to have treatments as columns
mean_meth_wide <- mean_meth %>%
  pivot_wider(names_from = treatment, values_from = mean_per_meth)

# Caluclate relative change and ratio in the enriched to the control treatment 
mean_meth_wide <- mean_meth_wide %>%
  mutate(relative_change = enriched - control,
         relative_change_ratio = enriched / control)

# Scatter plot of the realtive change ratio, ratio greater than 1 indicates that the enriched treatment has higher methylation than the control, while a ratio less than 1 indicates lower methylation in the enriched treatment, we see higher methylation in enriched for our DMGs
ggplot(mean_meth_wide, aes(x = gene, y = relative_change_ratio, color = relative_change_ratio)) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "Relative Change in Methylation Between Enriched and Control Treatments",
       x = "Gene",
       y = "Relative Change in Methylation") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))


```


# Assign hyper- and hypo- methylation from data using DMGs
```{r}
# We have DMGs already, so now find the mean difference between enriched and control to determine hyper and hypomethylated
# Data wrangling to calculate the mean percent methylation for each gene
aggregated_data <- methylation_data %>%
  group_by(gene, treatment) %>%
  summarize(percent.meth = mean(per.meth, na.rm = TRUE))

# Specify the name of the control treatment group
control_group <- "control"

# Filter data for the control group
control_data <- aggregated_data %>%
  filter(treatment == control_group) %>%
  select(gene, ControlMean = percent.meth)

# Merge with the original data to get the mean percent methylation for each gene and treatment
merged_data <- merge(aggregated_data, control_data, by = "gene", all.x = TRUE)

# Calculate the mean difference for each gene and treatment compared to the control to extract hyper and hypo methylated genes
merged_data$MeanDifference <- merged_data$percent.meth - merged_data$ControlMean

# Identify hyper and hypomethylated genes
# Adjust the threshold based on your specific criteria
hyper_genes <- merged_data$gene[merged_data$MeanDifference > 0]
hypo_genes <- merged_data$gene[merged_data$MeanDifference < 0]

# Assuming hyper_genes and hypo_genes are lists or vectors
num_hyper_genes <- length(hyper_genes) #194 Count of hypermethylated genes
num_hypo_genes <- length(hypo_genes) #158 Count of hypomethylated genes

# Add the 'direction' column to merged_data
merged_data <- merged_data %>%
  mutate(direction = case_when(
    MeanDifference > 0 ~ "hypermethylated",
    MeanDifference < 0 ~ "hypomethylated",
    TRUE ~ NA_character_
  ))

# Remove control rows
merged_data <- merged_data %>%
  filter(treatment != control_group)

# Assuming DMG.sig.annot.10x has a 'gene' column
# Merge the direction information back into the original DMG dataframe
DMG_all <- left_join(DMG.sig.annot.10x, merged_data %>% select(gene, direction), by = "gene")

# Select and keep specific columns (gene, direction, adj.pval.treatment)
methylation_data_selected <- DMG_all %>%
  select(gene, direction, adj.pval.treatment)

# Save CSV for DMG topGO analysis
write.csv(methylation_data_selected, "RAnalysis/Output/DMGs_all.csv")


```


# Conduct PERMANOVA and PCA on global methylation and DMG
#### Principal component plot of samples global meth
```{r}
#First need to make a matrix with percent meth count data for each sample and gene ID
#make meth count matrix, select gene, frag ID, and per meth from dataframe
#make meth count matrix, select gene, frag ID, and per meth from dataframe
matrix <- MD.10x %>%
  dplyr::select(gene, fragment.ID, per.meth)

#change from long to wide, set fun.aggregate for mean % meth per gene as it includes each position for each sample in the calculation
countdata <- reshape2::dcast(matrix, gene ~ fragment.ID, value.var = "per.meth", fun.aggregate = mean)

#make first row removed and rownames
countData <- countdata[,-1]
rownames(countData) <- countdata[,1]

#make all column values integers 
countData <- countData %>% mutate_if(is.numeric, as.integer)

#filter out sample 2, 19 and 16 from sample_info and colData data frame because they are not being used due to deduplication errors
samp.info <- sample.info[!row.names(sample.info) %in% c(2,16,19),]

# Define the columns to remove
columns_to_remove <- c("PV_7", "PV_8", "PV_28")  # Adjust with the column names you want to remove

# Remove columns from colData
countData <- countData[, !colnames(countData) %in% columns_to_remove]

##Merge the treatment columns into a new column , group. Set group as a factor.
samp.info$treatment <- factor(samp.info$treatment, levels = c("control","enriched"))

# Update countData column names to match samp.info
colnames(countData) <- samp.info$fragment.ID

# Reorder countData columns to match the row names in samp.info
countData <- countData[, samp.info$fragment.ID]

# Update row names of samp.info to match countData columns
rownames(samp.info) <- samp.info$fragment.ID

# Check if colnames(countData) and rownames(samp.info) match
identical(sort(colnames(countData)), sort(rownames(samp.info)))  # Should be TRUE

#Set DESeq2 design
gdds <- DESeqDataSetFromMatrix(countData = countData,
                              colData = samp.info,
                              design = ~treatment)

#estimate size factors to determine if we can use vst  to transform our data. Size factors should be less than four to use vst
SF.gdds <- estimateSizeFactors(gdds) 
print(sizeFactors(SF.gdds))

#Our size factors are all less than 4, so we can use VST!
#apply a variance stabilizing transformation to minimize effects of small counts and normalize library size
# Apply variance stabilizing transformation
gvst <- varianceStabilizingTransformation(gdds, blind=FALSE, fitType='local')

# Perform PCA and get variance explained
gPCAdata <- plotPCA(gvst, intgroup = c("treatment"), returnData=TRUE)
percentVar <- round(100 * attr(gPCAdata, "percentVar")) 

# Create PCA plot with ellipses
ggplot(gPCAdata, aes(x = PC1, y = PC2, color = treatment, fill = treatment)) + 
  geom_point(size = 3, shape = 21, color = "black") + 
  stat_ellipse(alpha = 0.2, size = 1) +  # Add ellipses with transparency
  xlab(paste0("PC1: ", percentVar[1], "% variance")) + 
  ylab(paste0("PC2: ", percentVar[2], "% variance")) + 
  scale_color_manual(values = c("control" = "grey", "enriched" = "black")) + 
  scale_fill_manual(values = c("control" = "grey", "enriched" = "black")) + 
  coord_fixed() + 
  theme_bw() + 
  theme(panel.border = element_blank(), 
        axis.line = element_line(colour = "black"),
        plot.background = element_blank());gPCAdata

ggsave(path = "RAnalysis/Output/", filename = "meth_general_PCA_plot_host.pdf")
ggsave(path = "RAnalysis/Output/", filename = "meth_general_PCA_plot_host.png")

```

# Visualize differentially methylated genes
```{r}
# Subset the results to include only significant differentially methylated genes
DMG.sig.result <- as.data.frame(DMG.sig.10x)

# Remove the first column and set gene names as rownames
DMG.sig.results <- DMG.sig.result[,-1]
rownames(DMG.sig.results) <- DMG.sig.result[,1]

# Prepare DMG dataset for DESeq2
DMG.results.all <- DMG.sig.results
DMG <- rownames(DMG.results.all) # Get list of gene names
DMG <- unique(DMG) # Ensure unique gene names
DMG_list <- gdds[which(rownames(gdds) %in% DMG)] # Filter DESeq2 object
print(dim(DMG_list)) # Check dimensions
print(counts(DMG_list)) # Verify counts

# Apply transformation to DMG list
DMGvst <- varianceStabilizingTransformation(DMG_list, blind=FALSE)
print(dim(DMGvst)) # Verify dimensions after transformation
print(assay(DMGvst)) # Inspect transformed data

# Caluclate PCA 
DMG_PCAdata <- plotPCA(DMGvst, intgroup = c("treatment"), returnData=TRUE)
percentVar_pca <- round(100 * attr(DMG_PCAdata, "percentVar"))

# Create PCA plot
DMG_PCA_plot <- ggplot(DMG_PCAdata, aes(x = PC1, y = PC2, color = treatment)) +
  geom_point(size = 3) +
  xlab(paste0("PC1: ", percentVar_pca[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar_pca[2], "% variance")) +
  scale_color_manual(values = c(control = "grey", enriched = "black")) +
  coord_fixed() +
  theme_bw() +
  theme(
    panel.border = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.text = element_text(size = 16),
    axis.title = element_text(size = 16),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 16)) +
  stat_ellipse() ; DMG_PCA_plot


# Plot heat map with diff expressed genes
# Make a matrix for computing similarity
mat <- assay(DMGvst)#[DEG.results.all, ] # make an expression object
mat <- mat - rowMeans(mat) #difference in expression compared to average across all samples
dim(mat)
ann_colors <- list(treatment= c(control="black", enriched="grey"))
df_DMG <- as.data.frame(colData(DMGvst)[c("treatment")]) #make dataframe for column naming and associated treatment
# Sort the columns of the matrix by treatment
treatment_order <- order(df_DMG$treatment)
mat <- mat[, treatment_order]
df_DMG <- df_DMG[treatment_order, , drop = FALSE]

# Generate the heatmap
DMG_heatmap <- pheatmap(
  mat, 
  scale = "row", 
  legend = TRUE, 
  annotation_legend = TRUE, 
  annotation_col = df_DMG, 
  annotation_colors = ann_colors,
  clustering_distance_rows = "euclidean", 
  clustering_method = "average",
  show_rownames = FALSE,
  show_colnames = TRUE,
  cluster_cols = FALSE);DMG_heatmap # Disable column clustering to maintain treatment order

pdf(file = "RAnalysis/Output/DMG_heatmap_host.pdf")
DMG_heatmap
dev.off()

png(file = "RAnalysis/Output/DMG_heatmap_host.png")
DMG_heatmap
dev.off()


```

# Conduct PERMANOVA and DMG
Build PERMANOVA model.  
```{r}
# Extract the transformed count data
DMG_data <- t(assay(DMGvst))  # Transpose the data so samples are rows

# Get the treatment information
treatment <- colData(DMGvst)$treatment

# Perform PERMANOVA
permanova_result <- adonis2(DMG_data ~ treatment, method = "euclidean", permutations = 999)

# Print the results
print(permanova_result)

# Optionally, you can also perform a test for homogeneity of multivariate dispersions
dispersion_test <- betadisper(vegdist(DMG_data, method = "euclidean"), group = treatment)
anova_dispersion <- anova(dispersion_test)
print(anova_dispersion)

# Visualize the dispersion
plot(dispersion_test)
```


### Make Volcano plot of hyper and hypo methylated DMGs
```{r}
# Run DESeq2 analysis
dds <- DESeq(gdds)

# Extract log2fold change values
results <- results(dds)
log2fold_change <- results$log2FoldChange
gene_names <- rownames(results)
log2fold_change_df <- data.frame(Gene = gene_names, Log2FoldChange = log2fold_change)

#rename gene column
log2fold_change_df <- log2fold_change_df %>%
  dplyr::rename(gene = Gene)

# Merge with the methylation data frame
final_df <- left_join(results.10x, log2fold_change_df, by = "gene")

#rename gene column
final_df <- final_df %>%
 dplyr::rename(log2FoldChange = Log2FoldChange)

final_df <- final_df %>%
  dplyr::rename(padj = adj.pval.treatment)

final_df <- final_df %>%
  dplyr::rename(pvalue = pval.treatment)

# Create a new column for -log10(padj), noticed outliers in data
final_df $log_padj <- -log10(final_df $padj)

# Remove rows where log_padj is greater than 10
final_df <- final_df[final_df$log_padj <= 100, ]

# Define criteria for hypermethylation, hypomethylation

final_df$methylation_status <- ifelse(final_df$padj > 0.05, "Not Significant",
                                       ifelse(final_df$log2FoldChange > 0, "Hypermethylated",
                                              ifelse(final_df$log2FoldChange < 0, "Hypomethylated", "Not Classified")))

# Set up the color palette for hyper, hypo, and non-significant genes
colors <- c("Hypermethylated" = "red", "Hypomethylated" = "blue", "Not Significant" = "black")

# Create the volcano plot using ggplot2
DMG.volcano <- ggplot(final_df, aes(x = log2FoldChange, y = -log10(padj), color = methylation_status)) +
  geom_point(alpha = 0.7, size = 2) +
  scale_color_manual(values = colors, name = "Methylation Status", 
                     breaks = c("Hypermethylated", "Hypomethylated", "Not Significant"),
                     labels = c("Hypermethylated (194)", "Hypomethylated (158)", "Not Significant"),
                     drop = FALSE) +  # Include all specified breaks in the legend
  labs(title = "", x = "log2FoldChange", y = "-log10(adjusted p-value)") +
  theme_bw() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black");DMG.volcano

ggsave("RAnalysis/Output/DMG.volcano.pdf", DMG.volcano, width = 8, height = 6, units = c("in"))
  
#load png image of DMG PCA

DMG.PCA <- readPNG("RAnalysis/Output/DMG_PCA_plot_host.png")

PCA.DMG <- rasterGrob(DMG.PCA, interpolate=TRUE)

Figure2 <- plot_grid( DMG.volcano, PCA.DMG, labels = c('A', 'B'), label_size = 14)

ggsave(filename=paste0("RAnalysis/Output/DMG.PCA.volcano.png"), plot=Figure2, dpi=300, width=12, height=5, units="in", limitsize = FALSE)

```

