---
title: "WGBS Markdown"
author: "daniellembecker"
date: "3/17/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Molecular Underpinnings Chronic Nutrient Enrichment Project

## WGBS Gene Ontology (GO) Enrichment Analysis
## Previous steps for DNA methylation include WGBS workflow in Bioinformatics>WGBS>WGBS workflow 

## Load Libraries

```{r message = FALSE, warning = FALSE}
library(plotrix) 
library(ggplot2)
library(gridExtra)
library(factoextra)
library(seacarb) 
library(dplyr)
library(pheatmap)
library(tidyverse)
library(genefilter)
library(base)
library("DESeq2")
library(cowplot)
if ("lsmeans" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('lsmeans') 
library(lsmeans)
if ("ontologyIndex" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('ontologyIndex') 
library(ontologyIndex)
if ("ontologySimilarity" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('ontologySimilarity')
library(ontologySimilarity)
library(data.table)
library(RColorBrewer)
if ("colorRamps" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('colorRamps')
library(colorRamps)
if ("limma" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('limma')
# Load the package
library(limma)
library(GSEABase)
library(here)
library(lme4)
library(vegan)
library(goseq)
library(ggpubr)
library(patchwork)
library(rstatix)
library(stringr)
library(readr)
library(png)
library(grid)
library(cowplot)
```

#Downloaded all final .bed files for and 10x from andromeda to desktop: scp -r danielle_becker@andromeda.uri.edu:/data/putnamlab/dbecks/Becker_E5/WGBS_Becker_E5/Becker_WGBS/CovtoCyto/*_enrichment.bed /Users/Danielle/Desktop/Putnam_Lab/Becker_E5/RAnalysis/Data/WGBS

###Libraries E7, E8, AND C28 had low data coverage, not moving forward with these samples in statistical steps

Methylation Analysis
## Loading genomic and annotation
```{r}
#load sample information
sample.info <- read.csv("RAnalysis/Data/metadata.WGBS.csv", header=T, sep=",", na.string="NA", stringsAsFactors = F) #read in info
#samp <- sample.info$Sample.ID # set sample info
#samp <- gsub("[_]", "-", samp) #remove extra characters

#load genes gff 
Genes <- read.csv("RAnalysis/Output/rename_structure_gff3.csv") #read in data fill
Genes <- Genes[,c(10,2,5,6, 11)] #select desired columns only
colnames(Genes) <- c("gene","scaffold", "start", "stop", "length") #rename columns
Genes$gene <-  gsub("_","_gene_", Genes$gene) #add _gene_g#

#Load annotation file
Annot <- read.csv("Functional_Annotation/pver_annot_full.csv", row.names = 1)
colnames(Annot)[1] <- "gene"

#edit gene ID to match GFF3
Annot$gene <-  gsub("\\..*","",Annot$gene) #remove the all after . "t#" number after the dash
Annot$gene <-  gsub("_","_gene_",Annot$gene) #add _gene_g#

#load all gene GO IDs organized and split
Gene.GO.IDs <- read.csv("Functional_Annotation/pver_GOterms_interprot_swissprot_blast_trembl_20211203.csv", row.names = 1)
colnames(Gene.GO.IDs) <- c("gene", "GO.IDs") #rename columns

#edit gene ID to match GFF3
Gene.GO.IDs$gene <-  gsub("\\..*","",Gene.GO.IDs$gene) #remove the all after . "t#" number after the dash
Gene.GO.IDs$gene <-  gsub("_","_gene_",Gene.GO.IDs$gene) #add _gene_g#
Gene.GO.IDs$GO.IDs <- as.character(Gene.GO.IDs$GO.IDs) #make IDs into characters
GO.IDs <-unique(Gene.GO.IDs$GO.IDs) #removes duplicates from columns, compiles both lists to get all GO terms without duplicates
```

#Load filtered methylation counts 10x (only need to run initially, redone on 20240814, commented out as we filtered SNPs from the output in the next section)
```{r}
# 
# #  #Merge final .bed files at 10x coverage
#   meth.data.10x <- list.files(path = "Bioinformatics/Data/10x_methcounts/", pattern = ".bed$", full.names=TRUE) %>%
#     purrr::set_names(.) %>% 
#     map_dfr(read.csv,.id="Sample.ID", header=FALSE, sep="\t", na.string="NA", stringsAsFactors = FALSE) %>% 
#     dplyr::select(-c(V3,V7:V14)) %>%
#     group_by(Sample.ID)
#   colnames(meth.data.10x) <- c("Sample.ID", "scaffold", "position","per.meth","meth","unmeth","gene")
#   meth.data.10x$gene <- gsub(";.*","",meth.data.10x$gene) #remove extra characters
#   meth.data.10x$gene <- gsub("ID=","",meth.data.10x$gene) #remove extra characters
#   meth.data.10x$Sample.ID <- gsub("Bioinformatics/Data/10x_methcounts//","",meth.data.10x$Sample.ID) #remove extra characters
#   meth.data.10x$Sample.ID <- gsub("_.*","",meth.data.10x$Sample.ID) #remove extra characters 
#   #meth.data.10x$Sample.ID <- gsub("-","_",meth.data.10x$Sample.ID) #remove extra characters
#   #meth.data.10x$Sample.ID <- gsub("/","",meth.data.10x$Sample.ID) #remove extra characters (backslash from sample.ID name)
#   MD.10x <- merge(meth.data.10x,sample.info, by="Sample.ID") #combine sample info and 10x coverage megafile
#  
#  # # # Filter genewiz sample IDs 2, 16, and 19 that had low coverage
#  # # # Define genewiz sample IDs with low coverage
#   low_coverage_samples <- c(2, 16, 19)
# # # # 
# # # # # Filter out these genewiz sample IDs from the combined dataset
#    MD.10x_filtered <- MD.10x[!MD.10x$Sample.ID %in% low_coverage_samples, ]
#    unique_sample_ids <- unique(MD.10x_filtered$Sample.ID)
#    print(unique_sample_ids)
# #  
# # # # #save sample info and percent methylation
#   saveRDS(MD.10x_filtered, "RAnalysis/Output/sample_all_methylated_data_10x.Rdata")

```

# Filter out any SNPs that could impact our methylation data and use updated and filtered data frame for next steps
```{r}
# Filtering SNPs found from BS-SNper, following this workflow: https://github.com/daniellembecker/DanielleBecker_Lab_Notebook/blob/master/_posts/2024-02-12-Testing-BS-SNPer-Molec-Underpinnings-WGBS.md and this script: https://github.com/hputnam/Becker_E5/blob/master/RAnalysis/Scripts/WGBS/BS-SNPer.filter.Rmd

# Use the new MD.10x file that has now been filtered for SNPs
MD.10x <- readRDS("RAnalysis/Data/filtered_bed_SNP_file.Rdata") #read in info

head(MD.10x)


#MD.10x_filtered <- MD.10x %>%
#  dplyr::filter(!fragment.ID %in% c("PV_26"))

```


# Testing for Differentially Methylated Genes at 10X coverage
```{r}
# Comparison of enriched vs control nutrient treatments
# At 10x coverage
# Binomial GLM to test for differentially methylated genes
 sub_meth_table.10x  <- MD.10x
 sub_meth_table.10x$group <- paste0(sub_meth_table.10x$Sample.ID, sub_meth_table.10x$gene)

# Filter genes with >=5 methylated positions
 min.filt.10x <- dplyr::count(sub_meth_table.10x, vars = c(group))
 newdata.10x <- min.filt.10x[min.filt.10x$n >= 5, ]
 sub_meth_table.10x <- sub_meth_table.10x[sub_meth_table.10x$group %in% newdata.10x$vars,]

# Initialize results dataframe
 results.10x <- data.frame()
 gs.10x <- unique(sub_meth_table.10x$gene)
 
# Calculate differentially methylated genes
# Commented out as it does not need to be run everytime, dataframes are saved and script can be run with commment out
#first subset the unique dataframes and second run the GLMs
#purr package function called map, much cleaner for for loops (how to loop over a model in the tidyverse, can have a tidy output for your anova) computational time is faster with purr and it is cleaner
 for(i in 1:length(sub_meth_table.10x$gene)){
 
#subset the dataframe gene by gene
sub_meth_table.10x1 <- subset(sub_meth_table.10x, gene ==gs.10x[i])
 
# fit glm position model
#think about this as just a logistic regression, linear model on binomial distribution is binomial distribution, just adding a random effect for block. P-values based off of maximum likelihood approach, not gonna be like an anova table. 
 fit <- glm(matrix(c(meth, unmeth), ncol=2) ~ treatment, 
             data=sub_meth_table.10x1, family=binomial)
   a <- anova(fit, test="Chisq")
  
# capture summary stats to data frame
    df <- data.frame(gene = sub_meth_table.10x1[1,7],
                     pval.treatment = a$`Pr(>Chi)`[2],
                 #pval.position = a$`Pr(>Chi)`[3], #uncomment if you want to include position of CpG within a gene
               #pval.treatment_x_position = a$`Pr(>Chi)`[4], #uncomment if you want to include position of CpG within a gene interaction with treatment
                     stringsAsFactors = F)

# bind rows of temporary data frame to the results data frame
    results.10x <- rbind(results.10x, df)

  }

# write dataframe
write.csv(results.10x, "RAnalysis/Output/meth.results.10x.csv")
#An error will be generated here for contrasts. 
#This potential for contrasts (interactions) is included in the case one wants to examine the role of position of CpG within a gene
#Continuing the analysis from results line will generate the results in the absence of the contrast (interaction).

results.10x <- read.csv("RAnalysis/Output/meth.results.10x.csv", row.names = 1)
results.10x[is.na(results.10x)] <- 0
results.10x$adj.pval.treatment <- p.adjust(results.10x$pval.treatment, method='BH') #BH is a less conservative Benjamini & Hochberg (1995) correction in which p-values are multiplied by the number of comparisons

#results$adj.pval.position <- p.adjust(results$pval.position, method='BH') #uncomment if you want to include position of CpG within a gene
#result $adj.pval.treatment_x_position <- p.adjust(results$pval.treatment_x_position, method='BH') #uncomment if you want to include position of CpG within a gene interaction with treatment

# Identifying DMG with significant main effect 
DMG.sig.10x <- results.10x
DMG.sig.10x <- DMG.sig.10x[order(DMG.sig.10x$adj.pval.treatment),]
DMG.sig.10x <- DMG.sig.10x[which(DMG.sig.10x$adj.pval.treatment<0.05), ]
sum(DMG.sig.10x$adj.pval.treatment < 0.05, na.rm=TRUE) #How many adjusted p-values were less than 0.05?

#376

#DMG.sig.10x_w_outlier <- DMG.sig.10x
#DMG.sig.10x_wo_outlier <- DMG.sig.10x

#overlap_genes <- intersect(DMG.sig.10x_w_outlier$gene, DMG.sig.10x_wo_outlier$gene) #318

# Number of overlapping gene_ids
#num_overlap <- length(overlap_genes)
#print(paste("Number of overlapping gene_ids:", num_overlap))


# Annotation of DMG under between treatments 
DMG.sig.annot.10x <- left_join(DMG.sig.10x , Annot, by="gene")
#DMG.sig.annot <- DMG.sig.annot[!duplicated(DMG.sig.annot$gene),]
write.table(DMG.sig.annot.10x, 'RAnalysis/Output/Treatment_sig_annot.10x.tsv', sep='\t', row.names=FALSE)

# Sanity check to make sure DMGs are calculated correctly
# Select data from MD.10x with significant DMGs
methylation_data <- MD.10x %>%
  filter(gene %in% DMG.sig.annot.10x$gene)

# Calculate relative change to confirm differential methylation calculated correctly 
# Calculate mean methylation per treatment
mean_meth <- methylation_data %>%
  group_by(gene, treatment) %>%
  summarize(mean_per_meth = mean(per.meth), .groups = 'drop')

# Widen data to have treatments as columns
mean_meth_wide <- mean_meth %>%
  pivot_wider(names_from = treatment, values_from = mean_per_meth)

# Calculate relative change and ratio in the enriched to the control treatment 
mean_meth_wide <- mean_meth_wide %>%
  mutate(relative_change = (enriched - control) / control)

# Scatter plot of the realtive change ratio, ratio greater than 1 indicates that the enriched treatment has higher methylation than the control, while a ratio less than 1 indicates lower methylation in the enriched treatment, we see higher methylation in enriched for our DMGs
ggplot(mean_meth_wide, aes(x = gene, y = relative_change, color = relative_change)) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "Relative Change in Methylation Between Enriched and Control Treatments",
       x = "Gene",
       y = "Relative Change in Methylation") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# compare with old data set:
old <- read.csv("../../../Desktop/old_DMG_data.csv")[-1]

# Calculate relative change to confirm differential methylation calculated correctly 
# Calculate mean methylation per treatment
mean_meth <- old %>%
  group_by(gene, treatment) %>%
  summarize(mean_per_meth = mean(per.meth), .groups = 'drop')

# Widen data to have treatments as columns
mean_meth_wide <- mean_meth %>%
  pivot_wider(names_from = treatment, values_from = mean_per_meth)

# Calculate relative change and ratio in the enriched to the control treatment 
mean_meth_wide <- mean_meth_wide %>%
  mutate(relative_change = (enriched - control) / control)

# Scatter plot of the realtive change ratio, ratio greater than 1 indicates that the enriched treatment has higher methylation than the control, while a ratio less than 1 indicates lower methylation in the enriched treatment, we see higher methylation in enriched for our DMGs
ggplot(mean_meth_wide, aes(x = gene, y = relative_change, color = relative_change)) +
  geom_point(size = 3) +
  theme_minimal() +
  labs(title = "Relative Change in Methylation Between Enriched and Control Treatments",
       x = "Gene",
       y = "Relative Change in Methylation") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))



```


# Assign hyper- and hypo- methylation from data using DMGs
```{r}
# We have DMGs already, so now find the mean difference between enriched and control to determine hyper and hypomethylated
# Data wrangling to calculate the mean percent methylation for each gene
aggregated_data <- methylation_data %>%
  group_by(gene, treatment) %>%
  summarize(percent.meth = mean(per.meth, na.rm = TRUE))

# Specify the name of the control treatment group
control_group <- "control"

# Filter data for the control group
control_data <- aggregated_data %>%
  filter(treatment == control_group) %>%
  select(gene, ControlMean = percent.meth)

# Merge with the original data to get the mean percent methylation for each gene and treatment
merged_data <- merge(aggregated_data, control_data, by = "gene", all.x = TRUE)

# Calculate the mean difference for each gene and treatment compared to the control to extract hyper and hypo methylated genes
merged_data$MeanDifference <- merged_data$percent.meth - merged_data$ControlMean

# Identify hyper and hypomethylated genes
# Adjust the threshold based on your specific criteria
hyper_genes <- merged_data$gene[merged_data$MeanDifference > 0]
hypo_genes <- merged_data$gene[merged_data$MeanDifference < 0]

# Assuming hyper_genes and hypo_genes are lists or vectors
num_hyper_genes <- length(hyper_genes) #206 Count of hypermethylated genes
num_hypo_genes <- length(hypo_genes) #170 Count of hypomethylated genes

# Add the 'direction' column to merged_data
merged_data <- merged_data %>%
  mutate(methylation_status = case_when(
    MeanDifference > 0 ~ "hypermethylated",
    MeanDifference < 0 ~ "hypomethylated",
    TRUE ~ NA_character_
  ))

# Remove control rows
merged_data <- merged_data %>%
  filter(treatment != control_group)

# Assuming DMG.sig.annot.10x has a 'gene' column
# Merge the direction information back into the original DMG dataframe
DMG_all <- left_join(DMG.sig.annot.10x, merged_data %>% select(gene, methylation_status), by = "gene")

# Select and keep specific columns (gene, direction, adj.pval.treatment)
methylation_data_selected <- DMG_all %>%
  select(gene, methylation_status, adj.pval.treatment)

# Save CSV for DMG topGO analysis
write.csv(methylation_data_selected, "RAnalysis/Output/DMGs_all.csv")


```


# Conduct PERMANOVA and PCA on global methylation and DMG
#### Principal component plot of samples global meth
```{r}
#First need to make a matrix with percent meth count data for each sample and gene ID
#make meth count matrix, select gene, frag ID, and per meth from dataframe
matrix <- MD.10x %>%
  dplyr::select(gene, fragment.ID, per.meth)

#change from long to wide, set fun.aggregate for mean % meth per gene as it includes each position for each sample in the calculation
countdata <- reshape2::dcast(matrix, gene ~ fragment.ID, value.var = "per.meth", fun.aggregate = mean)

#make first row removed and rownames
countData <- countdata[,-1]
rownames(countData) <- countdata[,1]

#make all column values integers 
countData <- countData %>% mutate_if(is.numeric, as.integer)

#filter out sample IDs 2, 19 and 16 from sample_info and colData data frame because they are not being used due to deduplication errors
samp.info <- sample.info[!row.names(sample.info) %in% c(2,16,19),]

# Define the columns for libraries to remove
columns_to_remove <- c("PV_7", "PV_8", "PV_28")  # Adjust with the column names you want to remove

# Remove columns from colData
countData <- countData[, !colnames(countData) %in% columns_to_remove]

##Merge the treatment columns into a new column , group. Set group as a factor.
samp.info$treatment <- factor(samp.info$treatment, levels = c("control","enriched"))

# Update countData column names to match samp.info
colnames(countData) <- samp.info$fragment.ID

# Reorder countData columns to match the row names in samp.info
countData <- countData[, samp.info$fragment.ID]

# Update row names of samp.info to match countData columns
rownames(samp.info) <- samp.info$fragment.ID

# Check if colnames(countData) and rownames(samp.info) match
identical(sort(colnames(countData)), sort(rownames(samp.info)))  # Should be TRUE

#Set DESeq2 design
gdds <- DESeqDataSetFromMatrix(countData = countData,
                              colData = samp.info,
                              design = ~treatment)

#estimate size factors to determine if we can use vst  to transform our data. Size factors should be less than four to use vst
SF.gdds <- estimateSizeFactors(gdds) 
print(sizeFactors(SF.gdds))

#Our size factors are all less than 4, so we can use VST!
#apply a variance stabilizing transformation to minimize effects of small counts and normalize library size
# Apply variance stabilizing transformation
gvst <- varianceStabilizingTransformation(gdds, blind=FALSE, fitType='local')

# Perform PCA and get variance explained
gPCAdata <- plotPCA(gvst, intgroup = c("treatment"), returnData=TRUE)
percentVar <- round(100 * attr(gPCAdata, "percentVar")) 

# Create PCA plot with ellipses
ggplot(gPCAdata, aes(x = PC1, y = PC2, color = treatment, fill = treatment)) + 
  geom_point(size = 3, shape = 21, color = "black") + 
  stat_ellipse(alpha = 0.2, size = 1) +  # Add ellipses with transparency
  xlab(paste0("PC1: ", percentVar[1], "% variance")) + 
  ylab(paste0("PC2: ", percentVar[2], "% variance")) + 
  scale_color_manual(values = c("control" = "grey", "enriched" = "black")) + 
  scale_fill_manual(values = c("control" = "grey", "enriched" = "black")) + 
  coord_fixed() + 
  theme_bw() + 
  theme(panel.border = element_blank(), 
        axis.line = element_line(colour = "black"),
        plot.background = element_blank());gPCAdata

ggsave(path = "RAnalysis/Output/", filename = "meth_general_PCA_plot_host.pdf")
ggsave(path = "RAnalysis/Output/", filename = "meth_general_PCA_plot_host.png")

```

# Visualize differentially methylated genes
```{r}
# Subset list of genes by those which padj>0.
DMG.sig.result <- as.data.frame(DMG.sig.10x)

#make first row removed and add gene as rownames
DMG.sig.results <- DMG.sig.result[,-1]
rownames(DMG.sig.results) <- DMG.sig.result[,1]

# Prepare DMG dataset for DESeq2
DMG.results.all <- DMG.sig.results
DMG <- rownames(DMG.results.all) # Get list of gene names
DMG <- unique(DMG) # Ensure unique gene names
DMG_list <- gdds[which(rownames(gdds) %in% DMG)] # Filter DESeq2 object
print(dim(DMG_list)) # Check dimensions
print(counts(DMG_list)) # Verify counts

# Apply transformation to DMG list
DMGvst <- varianceStabilizingTransformation(DMG_list, blind=FALSE)
print(dim(DMGvst)) # Verify dimensions after transformation
print(assay(DMGvst)) # Inspect transformed data

# Perform PCA on the downsampled data
DMG_PCAdata <- plotPCA(DMGvst, intgroup = c("treatment"), returnData=TRUE)
percentVar <- round(100 * attr(DMG_PCAdata, "percentVar"))

# Create the PCA plot with the downsampled data
DMG_PCA_plot <- ggplot(DMG_PCAdata, aes(x = PC1, y = PC2, color = treatment)) +
  geom_point(size = 3) +
  xlab(paste0("PC1: ", percentVar[1], "% variance")) +
  ylab(paste0("PC2: ", percentVar[2], "% variance")) +
  scale_color_manual(values = c(control = "grey", enriched = "black")) +
  coord_fixed() +
  theme_bw() +
  theme(
    panel.border = element_blank(),
    axis.line = element_line(colour = "black"),
    plot.background = element_blank(),
    axis.text = element_text(size = 16),
    axis.title = element_text(size = 16),
    legend.text = element_text(size = 16),
    legend.title = element_text(size = 16)) +
  stat_ellipse(); DMG_PCA_plot



```

# Conduct PERMANOVA and DMG
Export data for PERMANOVA test.  
```{r}
test2<-t(assay(DMGvst)) #export as matrix
test2<-as.data.frame(test2)

#add category columns
test2$fragment.ID <- rownames(test2)
test2$treatment <- samp.info$treatment[match(test2$fragment.ID, samp.info$fragment.ID)]
```

Build PERMANOVA model.  
```{r}
# Perform PCA on the numeric columns
pca_result <- prcomp(test2[1:376], center = TRUE, scale. = TRUE)

# Visualize PCA eigenvalues
fviz_eig(pca_result)

# scale data
scaled_test2 <- scale(test2[1:376])

# Print results
distance_matrix <- vegdist(scaled_test2, method = "euclidean")

# PERMANOVA
permanova_result <- adonis2(distance_matrix ~ treatment, data = test2)

# Print results
print(permanova_result)
```


Make heatmmap for DMGs
```{r}
# Plot heat map with diff expressed genes
# Make a matrix for computing similarity
mat <- assay(DMGvst)#[DEG.results.all, ] # make an expression object
mat <- mat - rowMeans(mat) #difference in expression compared to average across all samples
dim(mat)
ann_colors <- list(treatment= c(control="black", enriched="grey"))
df_DMG <- as.data.frame(colData(DMGvst)[c("treatment")]) #make dataframe for column naming and associated treatment
# Sort the columns of the matrix by treatment
treatment_order <- order(df_DMG$treatment)
mat <- mat[, treatment_order]
df_DMG <- df_DMG[treatment_order, , drop = FALSE]

# Generate the heatmap
DMG_heatmap <- pheatmap(
  mat, 
  scale = "row", 
  legend = TRUE, 
  annotation_legend = TRUE, 
  annotation_col = df_DMG, 
  annotation_colors = ann_colors,
  clustering_distance_rows = "euclidean", 
  clustering_method = "average",
  show_rownames = FALSE,
  show_colnames = TRUE,
  cluster_cols = FALSE);DMG_heatmap # Disable column clustering to maintain treatment order

pdf(file = "RAnalysis/Output/DMG_heatmap_host.pdf")
DMG_heatmap
dev.off()

png(file = "RAnalysis/Output/DMG_heatmap_host.png")
DMG_heatmap
dev.off()
```


### Make Volcano plot of hyper and hypo methylated DMGs
```{r}
# Run DESeq2 analysis
dds <- DESeq(gdds)

# Extract log2fold change values
results <- results(dds)
log2fold_change <- results$log2FoldChange
gene_names <- rownames(results)
log2fold_change_df <- data.frame(Gene = gene_names, Log2FoldChange = log2fold_change)

#rename gene column
log2fold_change_df <- log2fold_change_df %>%
  dplyr::rename(gene = Gene)

# Merge with the methylation data frame
final_df <- left_join(results.10x, log2fold_change_df, by = "gene")

#rename gene column
final_df <- final_df %>%
 dplyr::rename(log2FoldChange = Log2FoldChange)

final_df <- final_df %>%
  dplyr::rename(padj = adj.pval.treatment)

final_df <- final_df %>%
  dplyr::rename(pvalue = pval.treatment)

# Create a new column for -log10(padj), noticed outliers in data
final_df $log_padj <- -log10(final_df $padj)

# Remove rows where log_padj is greater than 10
final_df <- final_df[final_df$log_padj <= 100, ]

# Define criteria for hypermethylation, hypomethylation

final_df$methylation_status <- ifelse(final_df$padj > 0.05, "Not Significant",
                                       ifelse(final_df$log2FoldChange > 0, "Hypermethylated",
                                              ifelse(final_df$log2FoldChange < 0, "Hypomethylated", "Not Classified")))

# Set up the color palette for hyper, hypo, and non-significant genes
colors <- c("Hypermethylated" = "red", "Hypomethylated" = "blue", "Not Significant" = "black")

# Create the volcano plot using ggplot2
DMG.volcano <- ggplot(final_df, aes(x = log2FoldChange, y = -log10(padj), color = methylation_status)) +
  geom_point(alpha = 0.7, size = 2) +
  scale_color_manual(values = colors, name = "Methylation Status", 
                     breaks = c("Hypermethylated", "Hypomethylated", "Not Significant"),
                     labels = c("Hypermethylated (206)", "Hypomethylated (170)", "Not Significant"),
                     drop = FALSE) +  # Include all specified breaks in the legend
  labs(title = "", x = "log2FoldChange", y = "-log10(adjusted p-value)") +
  theme_bw() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "black");DMG.volcano

ggsave("RAnalysis/Output/DMG.volcano.pdf", DMG.volcano, width = 8, height = 6, units = c("in"))
  
#load png image of DMG PCA

#DMG.PCA <- readPNG("RAnalysis/Output/DMG_PCA_plot_host.png")


#PCA.DMG <- rasterGrob(DMG.PCA, interpolate=TRUE)

#Figure2 <- plot_grid( DMG.volcano, PCA.DMG, labels = c('A', 'B'), label_size = 14)

ggsave(filename=paste0("RAnalysis/Output/DMG.volcano.png"), plot=DMG.volcano, dpi=300, width=8, height=5, units="in", limitsize = FALSE)

```

```{r}
# Preprocess MD.10x data
# Create unique identifier for CpG sites
df <- MD.10x %>%
  mutate(ID = paste(scaffold, ":", position, sep = ""))

# Save df as a specific variable
all_CpG <- df

# Create ID column
all_CpG$ID <- paste(all_CpG$scaffold, ":", all_CpG$position, sep = "")

# Step 1: Create meta_data0
meta_data0 <- sample.info %>%
  mutate(sample = paste0(Sample.ID),
         group = paste(treatment)) %>%
  mutate_if(is.character, as.factor)

# Step 2: Select specific columns
meta_data0 <- meta_data0[, c("treatment", "Sample.ID", "group", "WGBS.lib.ID")]

# Step 3: Create meta_data
meta_data <- meta_data0 %>%
  arrange(WGBS.lib.ID) %>%
  column_to_rownames(var = "WGBS.lib.ID")

# Build %meth per CpG matrix
perc_methCpG <- all_CpG[, c("ID", "per.meth")]
perc_meth <- spread(perc_methCpG, ID, per.meth)
row.names(perc_meth) <- perc_meth$ID
perc_meth <- perc_meth[, -1]

# PCoA using Manhattan distance on raw percent data
sampleDists_Eu <- dist(t(perc_meth), method = "manhattan")
sampleDist_EuMatrix <- as.matrix(sampleDists_Eu)

mds <- as.data.frame(meta_data) %>% 
  cbind(cmdscale(sampleDist_EuMatrix)) %>%
  mutate(fillcol = factor(block),
         genet = as.character(block),
         alphaval = ifelse(treatment == "enriched", 1, 0))

# Calculate group centroids for plotting
mds <- mds %>%
  group_by(treatment) %>%
  dplyr::summarise(c1 = mean(`1`), c2 = mean(`2`)) %>%    
  full_join(mds)

# Calculate variance explained by each PC
MDS <- cmdscale(sampleDist_EuMatrix, eig = TRUE)
vexpl <- round(MDS$eig*100/sum(MDS$eig),1)[1:2]

# Plot with spiders
pcoa <- ggplot(mds, aes(color = genet, shape = sym)) +
  geom_segment(mapping = aes(x = `1`, y = `2`, xend = c1, yend = c2),
               lwd = 0.25, col = "grey") +
  geom_point(size = 2, aes(x = c1, y = c2, fill = genet, alpha = as.character(alphaval))) +
  geom_point(size = 2, aes(x = c1, y = c2), fill = ifelse(mds$alphaval, "white", NA)) +
  geom_point(size = 0.7, aes(x = `1`, y = `2`, fill = genet, alpha = as.character(alphaval)), show.legend = F) +
  geom_point(size = 0.7, aes(x = `1`, y = `2`), fill = ifelse(mds$alphaval, "white", NA), show.legend = F) +
  scale_shape_manual(values = c(21, 24)) +
  scale_alpha_manual(values = c(1, 0), name = "treatment", labels = c("control", "enriched")) +
  guides(shape = guide_legend(order = 2, override.aes = list(fill = "black"))) +
  guides(alpha = guide_legend(override.aes = list(shape = 21, alpha = 1, fill = c("black", "white")))) +
  labs(x = paste0("PC1 [", vexpl[1],"%]"), y = paste0("PC2 [", vexpl[2],"%]")) +
  theme_bw() +
  theme(legend.spacing.y = unit(0, "cm"))

print(pcoa)

# Save the plot
ggsave(filename = "pcoa.png", pcoa, width = 109, height = 84.5, units = "mm")

# Prepare data for DAPC analysis
coldata <- meta_data %>%
  rownames_to_column("ID") %>%
  as_tibble() %>%
  select(ID, block, sym, treatment, group)

colcounts <- perc_meth %>%
  rownames_to_column("gene") %>%
  as_tibble() %>%
  gather(key = "ID", value = "count", -gene) %>%
  mutate(count = count * 100) %>%
  mutate(count = round(count, 0))

countData <- round(perc_meth * 100, 0)

# Create DESeq dataset
dds <- DESeqDataSetFromMatrix(countData = countData,
                              colData = coldata,
                              design = ~ group)

vsd <- vst(dds, blind = FALSE)

# Remove batch effect
vsd2 <- limma::removeBatchEffect(assay(vsd), vsd$block)

# Use batch-block-removed vst counts
dat <- data.frame(vsd2) 

# Use regular vst counts
dat1 <- data.frame(assay(vsd))

# DAPC analysis
library(adegenet)

dapc2 <- dapc(t(dat1), coldata$group, n.da=3, n.pca=100)
temp <- optim.a.score(dapc2, n.sim = 25)

my.dapc <- function(n.pca) dapc(t(dat), coldata$group, n.pca = n.pca, n.da = 3)

scatter(dapc2, cell = 1, pch = 18:23, cstar = 0, scree.da = TRUE, scree.pca=TRUE, posi.pca = "topright",
        mstree = FALSE, lwd = 2, lty = 2)

library(furrr)
plan(multiprocess)

my.dapc.res <- tibble(n.pca = 10:30) %>%
  mutate(dapc = map(n.pca, my.dapc), 
         a.score = future_map(dapc, a.score, n.sim = 500),
         mean = map_dbl(a.score, ~ .$mean),
         cumvar = map_dbl(dapc, ~ .$var))

print(my.dapc.res %>% arrange(-mean))
```


```{r}
# Create a matrix of percent methylation
perc_meth <- df %>%
  select(ID, WGBS.lib.ID, per.meth) %>%
  pivot_wider(names_from = WGBS.lib.ID, values_from = per.meth, values_fill = 0)

# Set row names to ID
row.names(perc_meth) <- perc_meth$ID
perc_meth <- perc_meth[, -1]  # Remove the ID column

# Ensure the order of columns in perc_meth matches the order of rows in meta_data
perc_meth <- perc_meth[, rownames(meta_data)]

# Calculate mean methylation for each treatment
enriched_samples <- rownames(meta_data)[meta_data$treatment == "enriched"]
control_samples <- rownames(meta_data)[meta_data$treatment == "control"]

mean_enriched <- rowMeans(perc_meth[, enriched_samples], na.rm = TRUE)
mean_control <- rowMeans(perc_meth[, control_samples], na.rm = TRUE)

# Calculate difference in methylation
meth_diff <- mean_enriched - mean_control

# Create a dataframe with the results
results <- data.frame(
  ID = rownames(perc_meth),
  mean_enriched = mean_enriched,
  mean_control = mean_control,
  meth_diff = meth_diff
)

# Sort by absolute difference in methylation
results <- results[order(-abs(results$meth_diff)), ]

# View the top differences
print(head(results, 20))

# Histogram of methylation differences
hist(results$meth_diff, breaks = 50, main = "Distribution of Methylation Differences", 
     xlab = "Difference in Methylation (Enriched - Control)")

# Scatterplot of mean methylation levels
plot(results$mean_control, results$mean_enriched, 
     main = "Mean Methylation: Enriched vs Control",
     xlab = "Mean Methylation (Control)", 
     ylab = "Mean Methylation (Enriched)")
abline(a = 0, b = 1, col = "red")  # Add y=x line
```

