---
title: "methylkit_analysis"
author: "daniellembecker"
date: "2022-10-05"
output: html_document
---

## Followed the nfcore/methylseq workflow found here (https://github.com/hputnam/Becker_E5/blob/master/Bioinformatics/Workflows/Becker_WGBS_Workflow.md) to get bismark cytosine reports per sample that can be used for methylkit.

## I used the bismark guide to find out what the cytosine reports contain (https://www.bioinformatics.babraham.ac.uk/projects/bismark/Bismark_User_Guide.pdf). They show chromosome-position-strand-count meth-count unmeth-C context-trinucleotide context. These output files can be found in the CovtoCyto folder in your Andromeda output.

## Using the output from Bismark aligner with methylation information per base to put into methylkit following (https://groups.google.com/g/methylkit_discussion/c/89gjErcOmmU). With pipeline='bismarkCytosineReport', the function expects cytosine report files from Bismark, which have chr,start, strand, number of cytosines (methylated bases) , number of thymines (unmethylated bases),context and trinucletide context format.

## I followed the methylkit vignette below (https://www.bioconductor.org/packages/devel/bioc/vignettes/methylKit/inst/doc/methylKit.html)

## Load libraries
```{r}
library(methylKit)
```

# Reading in the methylation call data from bisulfite sequencing with methRead function. Reading in the data this way will return a methylRawList object which stores methylation information per sample for each covered base. 
```{r}
#treatment, 1-16 enriched, 17-32 control
#create a methylRawListDB object, which stores the same content as myobj from above
# For sake of subsequent analysis, file.list, sample.id and treatment option should have the same order. In the following example, files for enriched nutrients have enriched1-16 for treatment vector and as determined by treatment vector they belong to the same group. The control files have sample ids control17-32 and they belong to the same group as indicated by the treatment vector.
# assembly = a string that defines the genome assembly such as hg18, mm9. this is just a string for book keeping. It can be any string. Although, when using multiple files from the same assembly, this string should be consistent in each object.
# treatment a vector contatining 0 and 1 denoting which samples are control which samples are test
#pipeline = name of the alignment pipeline, it can be either "amp", "bismark","bismarkCoverage", "bismarkCytosineReport" or a list (default:'amp'). The methylation text files generated from other pipelines can be read as generic methylation text files by supplying a named list argument as "pipeline" argument. The named list should containt column numbers which denotes which column of the text file corresponds to values and genomic location of the methylation events. See Details for more on possible values for this argument.

# make .Rdata file in Andromeda
#file to large to store in Desktop/github, store in Andromeda and download when needed


load('RAnalysis/Data/WGBS/methylkit/methyl.Rdata')


```

# Descriptive statistics on samples
# Since we read the methylation data now, we can check the basic stats about the methylation data such as coverage and percent methylation. We now have a methylRawList object which contains methylation information per sample. The following command prints out percent methylation statistics for samples

```{r}

getMethylationStats(myobj[[12]],plot=FALSE,both.strands=FALSE)

```

# The following command plots the histogram for percent methylation distribution.The figure below is the histogram and numbers on bars denote what percentage of locations are contained in that bin. Typically, percent methylation histogram should have two peaks on both ends. In any given cell, any given base are either methylated or not. Therefore, looking at many cells should yield a similar pattern where we see lots of locations with high methylation and lots of locations with low methylation.

```{r}
getMethylationStats(myobj[[16]],plot=TRUE,both.strands=FALSE)
```

# We can also plot the read coverage per base information in a similar way, again numbers on bars denote what percentage of locations are contained in that bin. Experiments that are highly suffering from PCR duplication bias will have a secondary peak towards the right hand side of the histogram.
```{r}
getCoverageStats(myobj[[10]],plot=TRUE,both.strands=FALSE)
```

# The code below filters a methylRawList and discards bases that have coverage below 10X and also discards the bases that have more than 99.9th percentile of coverage in each sample.

```{r}
filtered.myobj=filterByCoverage(myobj,lo.count=10,lo.perc=NULL,
                                      hi.count=NULL,hi.perc=99.9)
```

# The following function will merge all samples to one object for base-pair locations that are covered in all samples. Setting destrand=TRUE (the default is FALSE) will merge reads on both strands of a CpG dinucleotide. This provides better coverage, but only advised when looking at CpG methylation (for CpH methylation this will cause wrong results in subsequent analyses). In addition, setting destrand=TRUE will only work when operating on base-pair resolution, otherwise setting this option TRUE will have no effect. The unite() function will return a methylBase object which will be our main object for all comparative analysis. The methylBase object contains methylation information for regions/bases that are covered in all samples.

```{r}
meth=unite(myobj, destrand=FALSE)

#take a look at the data content of methylBase object:
head(meth)

```

# We can check the correlation between samples using getCorrelation. This function will either plot scatter plot and correlation coefficients or just print a correlation matrix.

```{r}
#adjust plot margins

getCorrelation(meth, plot=TRUE)

```
# We can cluster the samples based on the similarity of their methylation profiles. The following function will cluster the samples and draw a dendrogram.

```{r}
clusterSamples(meth, dist="correlation", method="ward", plot=TRUE)
```

# We can also do a PCA analysis on our samples. The following function will plot a scree plot for importance of components.

```{r}
PCASamples(meth, screeplot=TRUE)
```

# We can also plot PC1 and PC2 axis and a scatter plot of our samples on those axis which will reveal how they cluster.

```{r}
PCASamples(meth)
```

# Percent methylation values can be extracted from methylBase object by using percMethylation function.

```{r}
# creates a matrix containing percent methylation values
perc.meth=percMethylation(meth)

  
```




