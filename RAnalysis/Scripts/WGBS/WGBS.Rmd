---
title: "WGBS Markdown"
author: "daniellembecker"
date: "3/17/2021"
output: html_document
editor_options: 
  chunk_output_type: console
---

# Molecular Underpinnings Chronic Nutrient Enrichment Project

## WGBS Gene Ontology (GO) Enrichment Analysis
## Previous steps for DNA methylation include WGBS workflow in Bioinformatics>WGBS>WGBS workflow 

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Load Libraries

```{r message = FALSE, warning = FALSE}
library(plotrix) 
library(ggplot2)
library(gridExtra)
library(seacarb) 
library(dplyr)
library(pheatmap)
library(tidyverse)
library(genefilter)
library(cowplot)
if ("lsmeans" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('lsmeans') 
library(lsmeans)
if ("ontologyIndex" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('ontologyIndex') 
library(ontologyIndex)
if ("ontologySimilarity" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('ontologySimilarity')
library(ontologySimilarity)
library(data.table)
library(RColorBrewer)
if ("colorRamps" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('colorRamps')
library(colorRamps)
library(GSEABase)
library(here)
library(lme4)
library(goseq)
library(ggpubr)
library(patchwork)
library(rstatix)

```

#Downloaded all final .bed files for 5x and 10x from bluewaves to desktop: scp -r danielle_becker@bluewaves.uri.edu:/data/putnamlab/dbecks/Becker_E5/WGBS_Becker_E5/Becker_WGBS/CovtoCyto/*_enrichment.bed /Users/Danielle/Desktop/Putnam_Lab/Becker_E5/RAnalysis/Data/WGBS

###Samples 19, 16, and 2 have low data coverage (see WGBS workflow in Bioinformatics>WGBS>WGBS workflow for further information), not moving forward with these samples in statistical steps

Methylation Analysis
## Loading genomic and annotation

```{r}
#load sample information
sample.info <- read.csv("RAnalysis/Data/WGBS/metadata.WGBS.csv", header=T, sep=",", na.string="NA", stringsAsFactors = F) #read in info
#samp <- sample.info$Sample.ID # set sample info
#samp <- gsub("[_]", "-", samp) #remove extra characters

#load genes gff 
Genes <- read.csv("RAnalysis/Genome/Pver_genome_assembly_v1.0.gene.gff3", head = TRUE, sep= " ") #read in data fill
Genes <- Genes[,c(9,1,4,5)] #select desired columns only
colnames(Genes) <- c("gene","scaffold", "start", "stop" ) #rename columns
Genes$gene <- gsub(";.*","",Genes$gene) #remove extra characters
Genes$gene <- gsub("ID=","",Genes$gene) #remove extra characters
Genes$length <- Genes$stop-Genes$start # calculated lengths from start and stop

#Load annotation file
Annot <- read.csv("Functional_Annotation/Final_Annotations/pver_annot_full.csv", row.names = 1)
colnames(Annot)[1] <- "gene"

#edit gene ID to match GFF3
Annot$gene <-  gsub("\\..*","",Annot$gene) #remove the all after . "t#" number after the dash
Annot$gene <-  gsub("_","_gene_",Annot$gene) #add _gene_g#


#load all gene GO IDs organized and split

Gene.GO.IDs <- read.csv("Functional_Annotation/Final_Annotations/pver_GOterms_interprot_swissprot_blast_trembl_20211203.csv", row.names = 1)
colnames(Gene.GO.IDs) <- c("gene", "GO.IDs", "database") #rename columns

#edit gene ID to match GFF3
Gene.GO.IDs$gene <-  gsub("\\..*","",Gene.GO.IDs$gene) #remove the all after . "t#" number after the dash
Gene.GO.IDs$gene <-  gsub("_","_gene_",Gene.GO.IDs$gene) #add _gene_g#
Gene.GO.IDs$GO.IDs <- as.character(Gene.GO.IDs$GO.IDs) #make IDs into characters
GO.IDs <-unique(Gene.GO.IDs$GO.IDs) #removes duplicates from columns, compiles both lists to get all GO terms without duplicates
```

#Load filtered methylation counts 10x 
```{r}
#Nyssa-stringr package, nice and clean so you can pipe and not have to rename, etc., use expression that does it all in one line regex 
#Merge final .bed files at 10x coverage
meth.data.10x <- list.files(path = "RAnalysis/Data/WGBS/10x_coverage/", pattern = ".bed$", full.names=TRUE) %>%
  purrr::set_names(.) %>% 
  map_dfr(read.csv,.id="Sample.ID", header=FALSE, sep="\t", na.string="NA", stringsAsFactors = FALSE) %>% 
  dplyr::select(-c(V3,V7:V14)) %>%
  group_by(Sample.ID)
colnames(meth.data.10x) <- c("Sample.ID", "scaffold", "position","per.meth","meth","unmeth","gene")
meth.data.10x$gene <- gsub(";.*","",meth.data.10x$gene) #remove extra characters
meth.data.10x$gene <- gsub("ID=","",meth.data.10x$gene) #remove extra characters
meth.data.10x$Sample.ID <- gsub("RAnalysis/Data/WGBS/10x_coverage//","",meth.data.10x$Sample.ID) #remove extra characters
meth.data.10x$Sample.ID <- gsub("_.*","",meth.data.10x$Sample.ID) #remove extra characters 
#meth.data.10x$Sample.ID <- gsub("-","_",meth.data.10x$Sample.ID) #remove extra characters
#meth.data.10x$Sample.ID <- gsub("/","",meth.data.10x$Sample.ID) #remove extra characters (backslash from sample.ID name)
MD.10x <- merge(meth.data.10x,sample.info, by="Sample.ID") #combine sample info and 10x coverage megafile

#save sample info and percent methylation
write.csv(MD.10x, "RAnalysis/Output/WGBS/sample_all_methylated_data_10x.csv")
```


# Testing for Differentially Methylated Genes at 10X coverage
```{r}
# Comparison of enriched vs control nutrient treatments
# At 10x coverage
# Binomial GLM to test for differentially methylated genes
sub_meth_table.10x  <- MD.10x
sub_meth_table.10x$group <- paste0(sub_meth_table.10x$Sample.ID, sub_meth_table.10x$gene)

#filter for genes with >5 methylated positions
min.filt.10x <- count(sub_meth_table.10x, vars = c( group))
newdata.10x <- min.filt.10x[ which(min.filt.10x$n > 4), ]
sub_meth_table.10x <- sub_meth_table.10x[sub_meth_table.10x$group %in% newdata.10x$vars,]

# create data frame to stored results
results.10x <- data.frame()
gs.10x <- unique(sub_meth_table.10x$gene)


#first subset the unique dataframes and second run the GLMs
#purr package function called map, much cleaner for for loops (how to loop over a model in the tidyverse, can have a tidy output for your anova) computational time is faster with purr and it is cleaner
for(i in 1:length(sub_meth_table.10x$gene)){
  
  #subset the dataframe gene by gene
  sub_meth_table.10x1 <- subset(sub_meth_table.10x, gene ==gs.10x[i])
  
  # fit glm position model
  #think about this as just a logistic regression, linear model on binomial distribution is binomial distribution, just adding a random effect for block. P-values based off of maximum likelihood approach, not gonna be like an anova table. 
  fit <- glm(matrix(c(meth, unmeth), ncol=2) ~ treatment, 
             data=sub_meth_table.10x1, family=binomial)
  a <- anova(fit, test="Chisq")
  
  # capture summary stats to data frame
  df <- data.frame(gene = sub_meth_table.10x1[1,7],
                   pval.treatment = a$`Pr(>Chi)`[2],
                   #pval.position = a$`Pr(>Chi)`[3], #uncomment if you want to include position of CpG within a gene
                   #pval.treatment_x_position = a$`Pr(>Chi)`[4], #uncomment if you want to include position of CpG within a gene interaction with treatment
                   stringsAsFactors = F)
  
  # bind rows of temporary data frame to the results data frame
  results.10x <- rbind(results.10x, df)
  
}

write.csv(results.10x, "RAnalysis/Output/WGBS/meth.results.10x.csv")

 # An error will be generated here for contrasts. 
#This potential for contrasts (interactions) is included in the case one wants to examine the role of position of CpG within a gene
#Error in `contrasts<-`(`*tmp*`, value = contr.funs[1 + isOF[nn]]) : contrasts can be applied only to factors with 2 or more levels
#Continuing the analysis from results line will generate the results in the absence of the contrast (interaction).

results.10x <- read.csv("RAnalysis/Output/WGBS/meth.results.10x.csv", row.names = 1)


results.10x[is.na(results.10x)] <- 0
results.10x$adj.pval.treatment <- p.adjust(results.10x$pval.treatment, method='BH') #BH is a less conservative Benjamini & Hochberg (1995) correction in which p-values are multiplied by the number of comparisons

#results$adj.pval.position <- p.adjust(results$pval.position, method='BH') #uncomment if you want to include position of CpG within a gene
#result $adj.pval.treatment_x_position <- p.adjust(results$pval.treatment_x_position, method='BH') #uncomment if you want to include position of CpG within a gene interaction with treatment

# Identifying DMG with significant main effect 
DMG.sig.10x <-results.10x
DMG.sig.10x <- DMG.sig.10x[order(DMG.sig.10x$adj.pval.treatment),]
DMG.sig.10x <- DMG.sig.10x[which(DMG.sig.10x$adj.pval.treatment<0.05), ]
sum(DMG.sig.10x$adj.pval.treatment < 0.05, na.rm=TRUE) #How many adjusted p-values were less than 0.05?

#368

# Annotation of DMG under between treatments 
DMG.sig.annot.10x <- left_join(DMG.sig.10x , Annot, by="gene")
#DMG.sig.annot <- DMG.sig.annot[!duplicated(DMG.sig.annot$gene),]
write.table(DMG.sig.annot.10x, 'RAnalysis/Output/WGBS/Treatment_sig_annot.10x.tsv', sep='\t', row.names=FALSE)


```

#plot global, DMG, and DMG per DEG for bar plots between enriched and control
```{r}
#Sanity check plotting of DMGs by treatment
subdf.DMG <- MD.10x  %>%	
  filter(gene== DMG.sig.annot.10x$gene[2])
means.DMG <- aggregate(per.meth ~ treatment, data=subdf.DMG, FUN=mean)
ses.DMG <- aggregate(per.meth ~ treatment, data=subdf.DMG, FUN=std.error)
means.DMG$ses <- ses.DMG$per.meth
means.DMG$per.meth <- means.DMG$per.meth

# build the linear model to see if tretaments differ and check assumptions
model  <- lm(per.meth ~ treatment, data = subdf.DMG)

# Create a QQ plot of residuals
ggqqplot(residuals(model))
#not normal, use kruskall willis test

# use Kruskal-Wallis test by rank which is a non-parametric alternative to one-way ANOVA test, which extends the two-samples Wilcoxon test in the situation where there are more than two groups. Itâ€™s recommended when the assumptions of one-way ANOVA test are not met.

DMG.mod <- kruskal.test(per.meth ~ treatment, data = subdf.DMG)

DMG.mod

#results: Kruskal-Wallis chi-squared = 118.91, df = 1, p-value < 2.2e-16, significantly higher percent meth in DMGs in enriched treatment

#make bar plot of means DMG
plot.DMG <- ggplot(means.DMG, aes(x=treatment, y=per.meth, fill = treatment)) +
  geom_bar(stat="identity",
             position=position_dodge(), show.legend = FALSE) +
    geom_errorbar(aes(ymin=per.meth-ses, ymax=per.meth+ses), width=.2,
                  position=position_dodge(.9)) +
    xlab("Treatment") + #plot x axis label
    ylab("Percent Methylation in DMG") + #plot y axis label
    scale_fill_manual(values = c(control="black", enriched="cadetblue3")) +
    scale_y_continuous(limits = c(0,12.5), expand = c(0, 0)) +
    ggtitle("Kruskal-Wallis, p < 2.2e-16") +
    theme_bw()

# #try the boxplot option here
# plot.DMG <- ggboxplot(subdf.DMG, x = "treatment", y = "per.meth",
#           color = "treatment")+
#   scale_color_manual(values = c(control="black", enriched="cadetblue3")) +
#   stat_compare_means(method = "kruskal.test") +
#   xlab("Treatment") + #plot x axis label
#     ylab("Percent Methylation in DMG") + #plot y axis label
#   scale_y_continuous(limits = c(0,70), expand = c(0, 0)) +
#   theme_bw()

ggsave("RAnalysis/Output/WGBS/per.meth.10x.DMG.pdf", plot.DMG)
ggsave("RAnalysis/Output/WGBS/per.meth.10x.DMG.png", plot.DMG)



#Sanity check plotting of DMGs by treatment
subdf.global <- MD.10x # %>%	
  #filter(gene== DMG.sig.annot.10x$gene[2])
means.global <- aggregate(per.meth ~ treatment, data=subdf.global, FUN=mean)
ses.global <- aggregate(per.meth ~ treatment, data=subdf.global, FUN=std.error)
means.global$ses <- ses.global$per.meth
means.global$per.meth <- means.global$per.meth

plot.global <- ggplot(means.global, aes(x=treatment, y=per.meth, fill = treatment)) +
  geom_bar(stat="identity",
             position=position_dodge(), show.legend = FALSE) +
    geom_errorbar(aes(ymin=per.meth-ses, ymax=per.meth+ses), width=.2,
                  position=position_dodge(.9)) +
    xlab("Treatment") + #plot x axis label
    ylab("Percent Methylation in Global") + #plot y axis label
    scale_fill_manual(values = c(control="black", enriched="cadetblue3")) +
    scale_y_continuous(expand = expansion(mult = c(0, .1)))+
    theme_bw()

ggsave("RAnalysis/Output/WGBS/per.meth.10x.global.pdf", plot.global)
ggsave("RAnalysis/Output/WGBS/per.meth.10x.global.png", plot.global)

#compare dmg and deg, create plot compared %dmgs in DEGs, load deg data
deg <- read.csv("RAnalysis/Output/RNA-seq/DEG/Host/DEGSeq2.sig.results.host.csv")

#make gene list for gene_id in deg dataframe
gene_list <-c(deg$gene_id)

#remove _gene_ in gene name from MD.10x
#MD.10x$gene <- gsub("_gene","", MD.10x$gene) #remove extra characters

#looking at percent methylation in DEG
subdf.dmg.deg <- MD.10x %>%	
  filter(gene %in% gene_list)
means.dmg.deg <- aggregate(per.meth ~ treatment, data=subdf.dmg.deg, FUN=mean)
ses.dmg.deg <- aggregate(per.meth ~ treatment, data=subdf.dmg.deg, FUN=std.error)
means.dmg.deg$ses <- ses.dmg.deg$per.meth
means.dmg.deg$per.meth <- means.dmg.deg$per.meth

plot.dmg.deg <- ggplot(means.dmg.deg, aes(x=treatment, y=per.meth, fill = treatment)) +
  geom_bar(stat="identity",
             position=position_dodge(), show.legend = FALSE) +
    geom_errorbar(aes(ymin=per.meth-ses, ymax=per.meth+ses), width=.2,
                  position=position_dodge(.9)) +
    xlab("Treatment") + #plot x axis label
    ylab("Percent Methylation in DEG") + #plot y axis label
    scale_fill_manual(values = c(control="black", enriched="cadetblue3")) +
    scale_y_continuous(expand = expansion(mult = c(0, .1)))+
    ggtitle("Kruskal-Wallis, p = 0.04") +
    theme_bw()

ggsave("RAnalysis/Output/WGBS/per.meth.in.DEG.pdf", plot.dmg.deg)
ggsave("RAnalysis/Output/WGBS/per.meth.in.DEG.png", plot.dmg.deg)


# build the linear model to see if tretaments differ and check assumptions
model  <- lm(per.meth ~ treatment, data = subdf.dmg.deg)

# Create a QQ plot of residuals
ggqqplot(residuals(model))
#not normal, use kruskall willis test

# use Kruskal-Wallis test by rank which is a non-parametric alternative to one-way ANOVA test, which extends the two-samples Wilcoxon test in the situation where there are more than two groups. Itâ€™s recommended when the assumptions of one-way ANOVA test are not met.

dmg.deg.mod <- kruskal.test(per.meth ~ treatment, data = subdf.dmg.deg)

dmg.deg.mod


```


# Conduct PERMANOVA and PCA on global methylation and DMG


#### Principal component plot of samples global DMG
```{r}
library("factoextra")


decathlon2.active <- subdf.DMG[1:2813, 4:9]

res.pca <- prcomp(decathlon2.active, scale = TRUE)

fviz_eig(res.pca)


gPCAdata <- plotPCA(gvst, intgroup = c("treatment"), returnData=TRUE)
percentVar <- round(100*attr(gPCAdata, "percentVar")) #plot PCA of samples with all data
ggplot(gPCAdata, aes(PC1, PC2, color=treatment)) + 
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) +
  scale_color_manual(values = c(control="black", enriched="cadetblue3")) +
  coord_fixed() +
  theme_bw() + #Set background color
  theme(panel.border = element_blank(), # Set border
        #panel.grid.major = element_blank(), #Set major gridlines
        #panel.grid.minor = element_blank(), #Set minor gridlines
        axis.line = element_line(colour = "black"), #Set axes color
        plot.background=element_blank()) + #Set the plot background +
  stat_ellipse()

ggsave(path = "RAnalysis/Output/Final_Figures/Host/", filename = "DMG_general_PCA_plot_host.pdf")

```



#### Principal component plot of samples sig DMG
```{r}

subdf.DMG

gPCAdata <- plotPCA(MD.10x, intgroup = c("treatment"), returnData=TRUE)
percentVar <- round(100*attr(gPCAdata, "percentVar")) #plot PCA of samples with all data
ggplot(gPCAdata, aes(PC1, PC2, color=treatment)) + 
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) +
  scale_color_manual(values = c(control="black", enriched="cadetblue3")) +
  coord_fixed() +
  theme_bw() + #Set background color
  theme(panel.border = element_blank(), # Set border
        #panel.grid.major = element_blank(), #Set major gridlines
        #panel.grid.minor = element_blank(), #Set minor gridlines
        axis.line = element_line(colour = "black"), #Set axes color
        plot.background=element_blank())  + #Set the plot background +
  stat_ellipse()

ggsave(path = "RAnalysis/Output/Final_Figures/Host/", filename = "DMG_general_PCA_plot_host.pdf")

```



## 10x GO enrichment
```{r}
# GO Enrichment Analysis of Treatment for 10x data
##### GO enrichment of DMGs #####

DMG.trt <- as.character(DMG.sig.10x$gene) #set the enrichment test list

#change to vectors
ALL.vector <-c(t(Genes$gene))
DMG.vector <-c(t(DMG.trt))
ID.vector <- Genes$gene
LENGTH.vector <-Genes$length

#DMG.trt.vector <-c(t(DMG.trt)) #change to vectors
gene.vector=as.integer(ALL.vector%in%DMG.vector) #Construct new vector with 1 for DEG and 0 for others
names(gene.vector)=ALL.vector #set names
DMG.pwf<-nullp(gene.vector, ID.vector, bias.data=LENGTH.vector) #weight vector by length of gene

#Find enriched GO terms, 
GO.wall<-goseq(DMG.pwf, ID.vector, gene2cat=Gene.GO.IDs, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)

GO.sig.trt <- GO.wall %>%
  filter(over_represented_pvalue <0.05) %>%
  arrange(., ontology)
write.csv(GO.sig.trt , file = "RAnalysis/Output/WGBS/GO.sig.trt.10x.csv")

#GO.sig.trt$term <- as.factor(GO.sig.trt$term)
GO.sig.trt[is.na(GO.sig.trt)] <- "UN"

nrow(GO.sig.trt) #118
nrow(filter(GO.sig.trt, ontology=="BP")) #number sig BP terms (75)
nrow(filter(GO.sig.trt, ontology=="MF")) #number sig MF terms (37)
nrow(filter(GO.sig.trt, ontology=="CC")) #number sig CC terms (6)

#check any missing GO terms manually and add as needed
which(GO.sig.trt$ontology=="UN")

GO.sig.trt[117,6] <- "innate immune response-activating signal transduction"
GO.sig.trt[117,7] <- "BP"

GO.sig.trt[118,6] <- "cell-cell adherens junction"
GO.sig.trt[118,7] <- "CC"

```

## Find GOslim terms
## This is where you put GO terms to larger umbrella terms

# Run GOslim to get broader categories
```{r}
#load in generic GO database, has all of the upperlevel categories for GO terms. Ex: regulation of cell division would be under cellular regulation
slim <- getOBOCollection("http://current.geneontology.org/ontology/subsets/goslim_generic.obo") #get GO database

## filtering all of BP (do MF and CC seperately)
BP_GO <- GO.sig.trt %>%
  filter(ontology=="BP")
BPGO_collection <- GOCollection(BP_GO$category) #Make library of query terms
slims_bp <- data.frame(goSlim(BPGO_collection, slim, "BP")) #Find common parent terms to slim down our list
slims_bp$category <- row.names(slims_bp) #save rownames as category

## filtering all of MF
MF_GO <- GO.sig.trt %>%
  filter(ontology=="MF")
MFGO_collection <- GOCollection(MF_GO$category) #Make library of query terms
slims_mf <- data.frame(goSlim(MFGO_collection, slim, "MF")) #Find common parent terms to slim down our list
slims_mf$category <- row.names(slims_mf) #save rownames as category

## filtering all of CC
CC_GO <- GO.sig.trt %>%
  filter(ontology=="CC")
CCGO_collection <- GOCollection(CC_GO$category) #Make library of query terms
slims_cc <- data.frame(goSlim(CCGO_collection, slim, "CC")) #Find common parent terms to slim down our list
slims_cc$category <- row.names(slims_cc) #save rownames as category
```

# Get mapped terms, using functions from Sam White's Biostars [post](https://support.bioconductor.org/p/128407/#128409).
```{r}
#custom function from Sam White's, gets mapped ids for all of your query terms 
#Write function mappedIds to get the query terms that mapped to the slim categories
mappedIds <-
  function(df, collection, OFFSPRING) #the command to run requires a dataframe of slim terms, like slims_MF above, your list of query terms, and the offspring from the GOCollection by goSlim
  {
    map <- as.list(OFFSPRING[rownames(df)]) # Subset GOcollection offspring by the rownames of your dataframe
    mapped <- lapply(map, intersect, ids(collection)) #Find the terms that intersect between the subset made above of your query terms and the GOids from the GO collection
    df[["go_terms"]] <- vapply(unname(mapped), paste, collapse = ";", character(1L)) #Add column "go_terms" with matching terms 
    df #show resulting dataframe
  }
#Run function for MF and BP terms
BPslim <- mappedIds(slims_bp, BPGO_collection, GOBPOFFSPRING)
MFslim <- mappedIds(slims_mf, MFGO_collection, GOMFOFFSPRING)
CCslim <- mappedIds(slims_cc, CCGO_collection, GOCCOFFSPRING)
```

# Remove duplicate matches, keeping the broader umbrella term
```{r}
#filtering out duplicates, keep the largest branch that has the most GO terms

#BP
BPslim <- filter(BPslim, Count>0 & Term!="biological_process") #filter out empty slims and term "biological process"
BPsplitted <- strsplit(as.character(BPslim$go_terms), ";") #split into multiple GO ids
BPslimX <- data.frame(Term = rep.int(BPslim$Term, sapply(BPsplitted, length)), go_term = unlist(BPsplitted)) #list all
BPslimX <- merge(BPslimX, BPslim[,c(1,3:4)], by="Term") #Add back counts, term, and category info
BPslimX <- unique(setDT(BPslimX)[order(go_term, -Count)], by = "go_term") #remove duplicate offspring terms, keeping only those that appear in the larger umbrella term (larger Count number)
BPslim <- data.frame(slim_term=BPslimX$Term, slim_cat=BPslimX$category, category=BPslimX$go_term) #rename columns
head(BPslim)

#MF
MFslim <- filter(MFslim, Count>0 & Term!="molecular_function") #filter out empty slims and term "molecular function"
MFsplitted <- strsplit(as.character(MFslim$go_terms), ";") #split into multiple GO ids
MFslimX <- data.frame(Term = rep.int(MFslim$Term, sapply(MFsplitted, length)), go_term = unlist(MFsplitted)) #list all
MFslimX <- merge(MFslimX, MFslim[,c(1,3:4)], by="Term")  #Add back counts, term, and category info
MFslimX <- unique(setDT(MFslimX)[order(go_term, -Count)], by = "go_term")  #remove duplicate offspring terms, keeping only
MFslim <- data.frame(slim_term=MFslimX$Term, slim_cat=MFslimX$category, category=MFslimX$go_term) #rename columns
head(MFslim)

#CC
CCslim <- filter(CCslim, Count>0 & Term!="cellular_component") #filter out empty slims and term "molecular function"
CCsplitted <- strsplit(as.character(CCslim$go_terms), ";") #split into multiple GO ids
CCslimX <- data.frame(Term = rep.int(CCslim$Term, sapply(CCsplitted, length)), go_term = unlist(CCsplitted)) #list all
CCslimX <- merge(CCslimX, CCslim[,c(1,3:4)], by="Term")  #Add back counts, term, and category info
CCslimX <- unique(setDT(CCslimX)[order(go_term, -Count)], by = "go_term")  #remove duplicate offspring terms, keeping only
CCslim <- data.frame(slim_term=CCslimX$Term, slim_cat=CCslimX$category, category=CCslimX$go_term) #rename columns
head(CCslim)

```

# Save slim info with GO enrichment info for heatmap dataframes.
```{r}
GO.BP <- right_join(BPslim, filter(GO.sig.trt, ontology=="BP"), by="category") #add back GO enrichment info for each offspring term
GO.MF <- right_join(MFslim, filter(GO.sig.trt, ontology=="MF"), by="category") #add back GO enrichment info for each offspring term
GO.CC <- right_join(CCslim, filter(GO.sig.trt, ontology=="CC"), by="category") #add back GO enrichment info for each offspring term
```


## Make heatmap
```{r}
BPplot <- GO.BP %>% mutate(term = fct_reorder(term, -over_represented_pvalue)) %>%
    ggplot(aes(x = ontology, y = term)) + 
    geom_tile(aes(fill=over_represented_pvalue, width = 1)) + 
      scale_y_discrete(position = "right") +
      facet_grid(slim_term~ ., scales = "free_y", labeller = label_wrap_gen(width = 10, multi_line = TRUE))+
      theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
      strip.text.y.left = element_text(angle=0, size = 11, face = "bold"),
      strip.text.x = element_text(size = 12, face = "bold"),
      axis.title = element_blank(),
      axis.text = element_text(size = 12), legend.title = element_text(size = 12), legend.text =     
      element_text(size = 11))
MFplot <- GO.MF %>% mutate(term = fct_reorder(term, -over_represented_pvalue)) %>% 
    ggplot(aes(x = ontology, y = term)) + 
    geom_tile(aes(fill=over_represented_pvalue, width = 1)) + 
      scale_y_discrete(position = "right") +
      facet_grid(slim_term~ ., scales = "free_y", labeller = label_wrap_gen(width = 10, multi_line = TRUE))+
      theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
      strip.text.y.left = element_text(angle=0, size = 11, face = "bold"),
      strip.text.x = element_text(size = 12, face = "bold"),
      axis.title = element_blank(),
      axis.text = element_text(size = 12), legend.title = element_text(size = 12), legend.text =
      element_text(size = 11))
fig5 <- BPplot + MFplot
ggsave("RAnalysis/Output/WGBS/DMG_heatmap_GO_terms.10x.pdf", fig5, width = 20, height = 20, units = c("in"))

```

## Make supplemental table summarizing GO enrichment
```{r}
GO.enrichment.summary.10x <- bind_rows(GO.BP, GO.MF, GO.CC)

#add gene_IDs. To get gene_IDs we will merge with the GO.terms DF.
GOgenes <- data.frame(gene_id=Gene.GO.IDs$gene, category=Gene.GO.IDs$GO.IDs) 
GOgenes$gene_id <- as.character(GOgenes$gene_id) #make gene ID a character so we can collapse our many near-identical columns

GO.enrichment.summary.10x  <- left_join(GO.enrichment.summary.10x, GOgenes, by="category" ) #join the DFs

#adjust p-values 
GO.enrichment.summary.10x$bh_adjust <-  p.adjust(GO.enrichment.summary.10x$over_represented_pvalue, method="BH")

GO.enrichment.summary.10x <- GO.enrichment.summary.10x %>% #collapse and have gene IDs for a particular term in a single row as a comma-sep list. 
  group_by(slim_term, slim_cat, category, over_represented_pvalue, under_represented_pvalue, numDEInCat, numInCat, term, ontology, bh_adjust) %>%
  summarise(genes = toString(gene_id)) %>% #rename collapsed gene_ID column "gene"
  ungroup()

head(GO.enrichment.summary.10x)
write.csv(GO.enrichment.summary.10x, 'RAnalysis/Output/WGBS/GO.enrichment.summary.table.ontology.10x.csv') 
```

######

<!-- ## 5x GO enrichment -->
<!-- ```{r} -->
<!-- # GO Enrichment Analysis of Treatment for 5x data -->
<!-- ##### GO enrichment of DMGs ##### -->

<!-- DMG.trt <- as.character(DMG.sig.5x$gene) #set the enrichment test list -->

<!-- #change to vectors -->
<!-- ALL.vector <-c(t(Genes$gene)) -->
<!-- DMG.vector <-c(t(DMG.trt)) -->
<!-- ID.vector <- Genes$gene -->
<!-- LENGTH.vector <-Genes$length -->

<!-- #DMG.trt.vector <-c(t(DMG.trt)) #change to vectors -->
<!-- gene.vector=as.integer(ALL.vector%in%DMG.vector) #Construct new vector with 1 for DEG and 0 for others -->
<!-- names(gene.vector)=ALL.vector #set names -->
<!-- DMG.pwf<-nullp(gene.vector, ID.vector, bias.data=LENGTH.vector) #weight vector by length of gene -->

<!-- #Find enriched GO terms,  -->
<!-- GO.wall<-goseq(DMG.pwf, ID.vector, gene2cat=Gene.GO.IDs, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE) -->

<!-- GO.sig.trt <- GO.wall %>% -->
<!--   filter(over_represented_pvalue <0.05) %>% -->
<!--   arrange(., ontology) -->
<!-- write.csv(GO.sig.trt , file = "RAnalysis/Output/WGBS/GO.sig.trt.5x.csv") -->

<!-- #GO.sig.trt$term <- as.factor(GO.sig.trt$term) -->
<!-- GO.sig.trt[is.na(GO.sig.trt)] <- "UN" -->

<!-- nrow(GO.sig.trt) #261 -->
<!-- nrow(filter(GO.sig.trt, ontology=="BP")) #number sig BP terms (164) -->
<!-- nrow(filter(GO.sig.trt, ontology=="MF")) #number sig MF terms (67) -->
<!-- nrow(filter(GO.sig.trt, ontology=="CC")) #number sig CC terms (28) -->

<!-- #check any missing GO terms manually and add as needed -->
<!-- which(GO.sig.trt$ontology=="UN") -->

<!-- GO.sig.trt[260,6] <- "obsolete nucleotide phosphatase activity, acting on free nucleotides" -->
<!-- GO.sig.trt[260,7] <- "MF" -->

<!-- GO.sig.trt[261,6] <- "obsolete C-terminal protein-tyrosinylation" -->
<!-- GO.sig.trt[261,7] <- "BP" -->

<!-- ``` -->

<!-- ## Find GOslim terms -->
<!-- ## This is where you put GO terms to larger umbrella terms -->

<!-- # Run GOslim to get broader categories -->
<!-- ```{r} -->
<!-- #load in generic GO database, has all of the upperlevel categories for GO terms. Ex: regulation of cell division would be under cellular regulation -->
<!-- slim <- getOBOCollection("http://current.geneontology.org/ontology/subsets/goslim_generic.obo") #get GO database -->

<!-- ## filtering all of BP (do MF and CC seperately) -->
<!-- BP_GO <- GO.sig.trt %>% -->
<!--   filter(ontology=="BP") -->
<!-- BPGO_collection <- GOCollection(BP_GO$category) #Make library of query terms -->
<!-- slims_bp <- data.frame(goSlim(BPGO_collection, slim, "BP")) #Find common parent terms to slim down our list -->
<!-- slims_bp$category <- row.names(slims_bp) #save rownames as category -->

<!-- ## filtering all of MF -->
<!-- MF_GO <- GO.sig.trt %>% -->
<!--   filter(ontology=="MF") -->
<!-- MFGO_collection <- GOCollection(MF_GO$category) #Make library of query terms -->
<!-- slims_mf <- data.frame(goSlim(MFGO_collection, slim, "MF")) #Find common parent terms to slim down our list -->
<!-- slims_mf$category <- row.names(slims_mf) #save rownames as category -->

<!-- ## filtering all of CC -->
<!-- CC_GO <- GO.sig.trt %>% -->
<!--   filter(ontology=="CC") -->
<!-- CCGO_collection <- GOCollection(CC_GO$category) #Make library of query terms -->
<!-- slims_cc <- data.frame(goSlim(CCGO_collection, slim, "CC")) #Find common parent terms to slim down our list -->
<!-- slims_cc$category <- row.names(slims_cc) #save rownames as category -->
<!-- ``` -->

<!-- # Get mapped terms, using functions from Sam White's Biostars [post](https://support.bioconductor.org/p/128407/#128409). -->
<!-- ```{r} -->
<!-- #custom function from Sam White's, gets mapped ids for all of your query terms  -->
<!-- #Write function mappedIds to get the query terms that mapped to the slim categories -->
<!-- mappedIds <- -->
<!--   function(df, collection, OFFSPRING) #the command to run requires a dataframe of slim terms, like slims_MF above, your list of query terms, and the offspring from the GOCollection by goSlim -->
<!--   { -->
<!--     map <- as.list(OFFSPRING[rownames(df)]) # Subset GOcollection offspring by the rownames of your dataframe -->
<!--     mapped <- lapply(map, intersect, ids(collection)) #Find the terms that intersect between the subset made above of your query terms and the GOids from the GO collection -->
<!--     df[["go_terms"]] <- vapply(unname(mapped), paste, collapse = ";", character(1L)) #Add column "go_terms" with matching terms  -->
<!--     df #show resulting dataframe -->
<!--   } -->
<!-- #Run function for MF and BP terms -->
<!-- BPslim <- mappedIds(slims_bp, BPGO_collection, GOBPOFFSPRING) -->
<!-- MFslim <- mappedIds(slims_mf, MFGO_collection, GOMFOFFSPRING) -->
<!-- CCslim <- mappedIds(slims_cc, CCGO_collection, GOCCOFFSPRING) -->
<!-- ``` -->

<!-- # Remove duplicate matches, keeping the broader umbrella term -->
<!-- ```{r} -->
<!-- #filtering out duplicates, keep the largest branch that has the most GO terms -->

<!-- #BP -->
<!-- BPslim <- filter(BPslim, Count>0 & Term!="biological_process") #filter out empty slims and term "biological process" -->
<!-- BPsplitted <- strsplit(as.character(BPslim$go_terms), ";") #split into multiple GO ids -->
<!-- BPslimX <- data.frame(Term = rep.int(BPslim$Term, sapply(BPsplitted, length)), go_term = unlist(BPsplitted)) #list all -->
<!-- BPslimX <- merge(BPslimX, BPslim[,c(1,3:4)], by="Term") #Add back counts, term, and category info -->
<!-- BPslimX <- unique(setDT(BPslimX)[order(go_term, -Count)], by = "go_term") #remove duplicate offspring terms, keeping only those that appear in the larger umbrella term (larger Count number) -->
<!-- BPslim <- data.frame(slim_term=BPslimX$Term, slim_cat=BPslimX$category, category=BPslimX$go_term) #rename columns -->
<!-- head(BPslim) -->

<!-- #MF -->
<!-- MFslim <- filter(MFslim, Count>0 & Term!="molecular_function") #filter out empty slims and term "molecular function" -->
<!-- MFsplitted <- strsplit(as.character(MFslim$go_terms), ";") #split into multiple GO ids -->
<!-- MFslimX <- data.frame(Term = rep.int(MFslim$Term, sapply(MFsplitted, length)), go_term = unlist(MFsplitted)) #list all -->
<!-- MFslimX <- merge(MFslimX, MFslim[,c(1,3:4)], by="Term")  #Add back counts, term, and category info -->
<!-- MFslimX <- unique(setDT(MFslimX)[order(go_term, -Count)], by = "go_term")  #remove duplicate offspring terms, keeping only -->
<!-- MFslim <- data.frame(slim_term=MFslimX$Term, slim_cat=MFslimX$category, category=MFslimX$go_term) #rename columns -->
<!-- head(MFslim) -->

<!-- #CC -->
<!-- CCslim <- filter(CCslim, Count>0 & Term!="cellular_component") #filter out empty slims and term "molecular function" -->
<!-- CCsplitted <- strsplit(as.character(CCslim$go_terms), ";") #split into multiple GO ids -->
<!-- CCslimX <- data.frame(Term = rep.int(CCslim$Term, sapply(CCsplitted, length)), go_term = unlist(CCsplitted)) #list all -->
<!-- CCslimX <- merge(CCslimX, CCslim[,c(1,3:4)], by="Term")  #Add back counts, term, and category info -->
<!-- CCslimX <- unique(setDT(CCslimX)[order(go_term, -Count)], by = "go_term")  #remove duplicate offspring terms, keeping only -->
<!-- CCslim <- data.frame(slim_term=CCslimX$Term, slim_cat=CCslimX$category, category=CCslimX$go_term) #rename columns -->
<!-- head(CCslim) -->

<!-- ``` -->

<!-- # Save slim info with GO enrichment info for heatmap dataframes. -->
<!-- ```{r} -->
<!-- GO.BP <- right_join(BPslim, filter(GO.sig.trt, ontology=="BP"), by="category") #add back GO enrichment info for each offspring term -->
<!-- GO.MF <- right_join(MFslim, filter(GO.sig.trt, ontology=="MF"), by="category") #add back GO enrichment info for each offspring term -->
<!-- GO.CC <- right_join(CCslim, filter(GO.sig.trt, ontology=="CC"), by="category") #add back GO enrichment info for each offspring term -->
<!-- ``` -->


<!-- ## Make heatmap -->
<!-- ```{r} -->
<!-- BPplot <- GO.BP %>% mutate(term = fct_reorder(term, -over_represented_pvalue)) %>% -->
<!--     ggplot(aes(x = ontology, y = term)) +  -->
<!--     geom_tile(aes(fill=over_represented_pvalue, width = 1)) +  -->
<!--       scale_y_discrete(position = "right") + -->
<!--       facet_grid(slim_term~ ., scales = "free_y", labeller = label_wrap_gen(width = 10, multi_line = TRUE))+ -->
<!--       theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), -->
<!--       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), -->
<!--       strip.text.y.left = element_text(angle=0, size = 11, face = "bold"), -->
<!--       strip.text.x = element_text(size = 12, face = "bold"), -->
<!--       axis.title = element_blank(), -->
<!--       axis.text = element_text(size = 12), legend.title = element_text(size = 12), legend.text =      -->
<!--       element_text(size = 11)) -->
<!-- MFplot <- GO.MF %>% mutate(term = fct_reorder(term, -over_represented_pvalue)) %>%  -->
<!--     ggplot(aes(x = ontology, y = term)) +  -->
<!--     geom_tile(aes(fill=over_represented_pvalue, width = 1)) +  -->
<!--       scale_y_discrete(position = "right") + -->
<!--       facet_grid(slim_term~ ., scales = "free_y", labeller = label_wrap_gen(width = 10, multi_line = TRUE))+ -->
<!--       theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(), -->
<!--       panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"), -->
<!--       strip.text.y.left = element_text(angle=0, size = 11, face = "bold"), -->
<!--       strip.text.x = element_text(size = 12, face = "bold"), -->
<!--       axis.title = element_blank(), -->
<!--       axis.text = element_text(size = 12), legend.title = element_text(size = 12), legend.text = -->
<!--       element_text(size = 11)) -->
<!-- fig5 <- BPplot + MFplot -->
<!-- ggsave("RAnalysis/Output/WGBS/DMG_heatmap_GO_terms.5x.pdf", fig5, width = 20, height = 20, units = c("in")) -->

<!-- ``` -->

<!-- ## Make supplemental table summarizing GO enrichment -->
<!-- ```{r} -->
<!-- GO.enrichment.summary.5x <- bind_rows(GO.BP, GO.MF, GO.CC) -->

<!-- #add gene_IDs. To get gene_IDs we will merge with the GO.terms DF. -->
<!-- GOgenes <- data.frame(gene_id=Gene.GO.IDs$gene, category=Gene.GO.IDs$GO.IDs)  -->
<!-- GOgenes$gene_id <- as.character(GOgenes$gene_id) #make gene ID a character so we can collapse our many near-identical columns -->

<!-- GO.enrichment.summary.5x  <- left_join(GO.enrichment.summary.5x, GOgenes, by="category" ) #join the DFs -->

<!-- #adjust p-values  -->
<!-- GO.enrichment.summary.5x$bh_adjust <-  p.adjust(GO.enrichment.summary.5x$over_represented_pvalue, method="BH") -->

<!-- GO.enrichment.summary.5x <- GO.enrichment.summary.5x %>% #collapse and have gene IDs for a particular term in a single row as a comma-sep list.  -->
<!--   group_by(slim_term, slim_cat, category, over_represented_pvalue, under_represented_pvalue, numDEInCat, numInCat, term, ontology, bh_adjust) %>% -->
<!--   summarise(genes = toString(gene_id)) %>% #rename collapsed gene_ID column "gene" -->
<!--   ungroup() -->

<!-- head(GO.enrichment.summary.5x) -->
<!-- write.csv(GO.enrichment.summary.5x, 'RAnalysis/Output/WGBS/GO.enrichment.summary.table.ontology.5x.csv')  -->
<!-- ``` -->




