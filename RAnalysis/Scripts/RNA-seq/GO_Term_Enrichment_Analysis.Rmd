---
title: "GO_Term_Enrichment_Analysis"
author: "daniellembecker"
edited by: "daniellembecker"
date: "9/20/2021"
output: html_document
---

# Molecular Underpinnings Chronic Nutrient Enrichment Project

## RNAseq Gene Ontology (GO) Enrichment Analysis 
## Previous steps include RNAseq workflow in Bioinformatics>RNAseq>RNAseq workflow and Differential Gene Expression statistical analysis in RAnalysis>Scripts>RNAseq_Differential_Gene_Expression to make DEG statistical data sheet


Load necessary libraries
```{r, echo=FALSE}
library(goseq)
library(tidyverse)
library(GSEABase)
library(data.table)
library(ggplot2)
library(cowplot)
library(patchwork)
library(ape)
library(stringr)
library(dplyr)
```

#if 28,153 + 27,439, does not equal 55,592 so all the names are different from test two files to test three files for KEGG terms 
#goal is to take sudo coded text into email, the most effective way to join three files and then identify what the offsets are for the three files to eachother, Megan suggested python blocking/grouping with key identifiers (Pver_g[0-9]) then you will know how many of those kinds of expressions are found in each of your lists; will tell you if they are fully missing 
#can sort everything into 'buckets' so that we can know how many general patterns there are before moving forward 

# Import the data files 
```{r}
#load gene functional annotation file (found in supplmental data from Buitrago-Lopez et al. 2020 paper https://academic.oup.com/gbe/article/12/10/1911/5898631#209703315)
Annot <- read_tsv( "RAnalysis/Genome/Pver_gene_annotation_file.txt", col_names = TRUE) #biological annotation information
colnames(Annot)[1] <- "gene_id" #set column name for consistency across files

#structural annotation file needed to calculate the length by stop position - start position 
#bring in the gene specific gff3 and pull out gene id 
GFF3 <- read.csv("RAnalysis/Genome/Pver_genome_assembly_v1.0.gene.gff3", header = FALSE, sep="", skip = 1)
length(unique(GFF3$V9)) # 27439
colnames(GFF3) <- c("prot", "Predict", "id", "start","stop", "pos1", "pos2","pos3", "gene_id") #name columns
GFF3$length <- GFF3$stop - GFF3$start #calculate gene length

#Load in and prep KofamScan search results
KFS.KO.orig <- read_tsv("RAnalysis/Genome/KEGG-ontology/Pver_KO_annot.tsv.gz", col_names = TRUE)
KFS.KO <- KFS.KO.orig[-1,-1] #remove the first row and column becasue they  contain no data
KFS.KO <- KFS.KO[, c(1,2,5)] #subset the gene ID, KO term, and evalue
colnames(KFS.KO) <- c("gene_id", "ko", "eval") #name columns
#NEED TO DECIDE KO TERM CUTOFF AND WHY OR WHY NOT TO KEEP MORE THAN ONE PER GENE
#FILTER FOR EVALUE AS NEEDED
KFS.KO <- KFS.KO[,c(1:2)] #remove evalue from the dataframe
Kegg.name <- as.data.frame(unique(KFS.KO$gene_id)) #identify all of the unique gene names
colnames(Kegg.name) <- c("gene_id") #set column name for consistency across files


#testing if there are inconsistencies in gene_ID formats across GO, gff3 and KO files
test.GFF.GO <- full_join(GFF3, Annot, by = "gene_id")
nrow(test.GFF.GO)
#conclusion: we have more genes than the expected 27,439, a number of gene ID names are present in the GO annotation file in annot that do not exist the gene names of the GFF3

test.GFF.KO <- full_join(GFF3, Kegg.name, by = "gene_id")
nrow(test.GFF.KO)
#conclusion: we have more genes than the expected 27,439, a number of gene ID names are present in the KEGG annotation file in annot that do not exist the gene names of the GFF3

test.GO.KO <- full_join(Annot, Kegg.name, by = "gene_id")
nrow(test.GO.KO)
#conclusion: we have the expected 27,439


#conclusion: All three files have the right number of gene_id rows = 27439.  When you join the functional annotation with the GFF3 they duplicate the number to = 54878. This indicates there is a naming inconsistency in all gene_id's. Need to investigate

#Let's start with the cannonical GFF3 file. This looks like it has duplicated names, so we can remove everything after the first ;

GFF3$gene_id <-  gsub(";.*","",GFF3$gene_id) #remove extra characters after the first ;
#There also appears to be the presence of the characters ID= in each row
GFF3$gene_id <- gsub("ID=","",GFF3$gene_id) #remove ID=

#format now appears to be Pver_gene_g1
#Let's count all of the occurrences of "Pver_gene_g" to see if this equals 27439
present <- GFF3 %>%
  filter(str_detect(gene_id, "Pver_gene_g"))
nrow(present)
#This is less than 27439, so we have other characters in the pattern as well

#Let's count all of the rows that do not have occurrences of "Pver_gene_g" 
absent <- GFF3 %>%
  filter(!str_detect(gene_id, "Pver_gene_g"))
nrow(absent)

#examine patterns of the rows not containing "Pver_gene_g" 
head(absent)
#found a pattern of "Pver_gene_split_gene_g408-g18"
tail(absent)
#found a pattern of "Pver_gene_novel_gene_742_5de57afd"

#we now have at least 3 formats
#Pver_gene_g#
#Pver_gene_novel_gene_#_5de57afd
#Pver_gene_split_gene_g1652-g72
#check to see of the sum of these rows = 27439

#Check Gene name format and number
novel <- GFF3 %>%
  filter(str_detect(gene_id, "novel"))
split <- GFF3 %>%
  filter(str_detect(gene_id, "split"))
remain <- GFF3 %>%
  filter(!str_detect(gene_id, "novel")) %>% filter(!str_detect(gene_id, "split"))
nrow(novel)+nrow(split)+nrow(remain) #should =27439
#yes, the sum is 27439
#we need to choose a cannonical gene_id format and convert all names to that format
#before we do that let's check gene_id in the GO and KO files as well



# GO functional annotation file
#Check Gene name format and number
unique(Annot$gene_id)
#the first identified format is Pver_g1.t2
#Let's remove everything after the period
Annot$gene_id <-  gsub("\\..*","",Annot$gene_id) #remove extra characters after the first .
#Let's add the _gene
Annot$gene_id <-  gsub("Pver_g","Pver_gene_g",Annot$gene_id) #add in the gene

test.GFF.GO <- full_join(GFF3, Annot, by = "gene_id")
nrow(test.GFF.GO)
#conclusion: we have 714 more genes than the expected 27,439 after we merge these two files, a number of gene ID names are present in the GO annotation file in annot that do not exist the gene names of the GFF3
tail(test.GFF.GO)

#let's test if there are the same 3 formats as the gff3

novel1 <- Annot %>%
  filter(str_detect(gene_id, "novel"))
nrow(novel1)

split1 <- Annot %>%
  filter(str_detect(gene_id, "split"))
nrow(split1)
#These characters do not appear in gene_id for the GO file

remain1 <- Annot %>%
  filter(!str_detect(gene_id, "novel")) %>% filter(!str_detect(gene_id, "split"))
nrow(remain1)

nrow(novel1)+nrow(split1)+nrow(remain1) #should =27439

#Annot has Pver_split_gene_g408-g408 and GFF3 has Pver_gene_split_gene_g408-g18 
GFF3$gene_id <- gsub("Pver_gene_split_gene_g","Pver_split_gene_g",GFF3$gene_id) #

# remove everthing after the -
Annot$gene_id <-  gsub("-.*","",Annot$gene_id)
GFF3$gene_id <-  gsub("-.*","",GFF3$gene_id)

test.GFF.GO <- full_join(GFF3, Annot, by = "gene_id")
nrow(test.GFF.GO)
#conclusion: we have 714 more genes than the expected 27,439 after we merge these two files, a number of gene ID names are present in the GO annotation file in annot that do not exist the gene names of the GFF3
tail(test.GFF.GO)



#GFF3 has #Pver_gene_novel_gene_281_5de57afd# and Annot does not

#Annot has "Pver_novel_gene_816_5de57afd" and GFF3 does not


######
#Let's gsub Pver_gene_novel_gene for Pver in the GFF3 and try again
GFF3$gene_id <-  gsub("Pver_gene_novel_gene_","Pver_novel_gene_",GFF3$gene_id) #remove extra characters

test.GFF.GO <- full_join(GFF3, Annot, by = "gene_id")
nrow(test.GFF.GO)
#conclusion: we have 84 more genes than the expected 27,439 after we merge these two files, a number of gene ID names are present in the GO annotation file in annot that do not exist the gene names of the GFF3
tail(test.GFF.GO)

#There are two gene ID formats in the Pver_genome_annotation file
#Pver_gene_g#
#Pver_novel_gene_#_5de57afd





# KEGG file
#Check Gene name format and number
novel2 <- KFS.KO %>%
  filter(str_detect(gene_id, "novel"))
length(unique(novel2$gene_id))

split2 <- KFS.KO %>%
  filter(str_detect(gene_id, "split"))
length(unique(split2$gene_id))

remain2 <- KFS.KO %>%
  filter(!str_detect(gene_id, "novel")) %>% filter(!str_detect(gene_id, "split"))
length(unique(remain2$gene_id))

#There are 3 formats in the Pver_KO_annot.tsv.gz
#Pver_g1.t2
#Pver_novel_model_1_5de57afd
#Pver_split_gene_g408-g408.t1-m18

# identifying GO term data for GO enrichment analysis
GO.data <- Annot[,c(2,13)] #select gene names and GO IDs
splitted <- strsplit(as.character(GO.data$Gene_ontology_IDs), "; ") #split into multiple GO IDs
Gene.GO.IDs <- data.frame(v1 = rep.int(GO.data$gene_id, sapply(splitted, length)), v2 = unlist(splitted)) #list all genes with each of their GO terms in a single row 
colnames(Gene.GO.IDs) <- c("gene_id", "GO.IDs") #rename columns
#Gene.GO.IDs$gene_id <-  gsub("_gene","",Gene.GO.IDs$gene_id) #remove extra characters
Gene.GO.IDs$GO.IDs <- as.character(Gene.GO.IDs$GO.IDs) #make IDs into characters
Gene.GO.IDs$gene_id <-  gsub("_gene","",Gene.GO.IDs$gene_id) #remove extra characters


#treatment information
treatmentinfo <- read.csv("RAnalysis/Data/RNA-seq/metadata.RNAseq.csv", header = TRUE, sep = ",")
str(treatmentinfo)
head(treatmentinfo)


#DEG significant results
DEG.res <- read.csv("RAnalysis/Output/RNA-seq/DEG/DEGSeq2.sig.results.csv")[,-1]
nrow(DEG.res)
DEG.res$gene_id <-  gsub("_gene","",DEG.res$gene_id) #remove extra characters
  
#ask Hollie about this
#filter DEGs for log2FoldChange>|1|
#DEG.res <- filter(DEG.res, log2FoldChange > 1 | log2FoldChange < (-1))
#nrow(DEG.res)

```

# Set ID and gene length vectors, and make a binary matrix indicating which genes are differentially expressed. These are used as input to nullp, which for calculates a Probability Weighting Function for each set of DEGs.
```{r}
#Make ID and length vectors

DEG.vector <- DEG.res$gene_id #the enrichment test list
ALL.vector <- GFF3$gene_id
ID.vector <- GFF3$gene_id #id obtained from gff3 file
length.vector <- GFF3$length #length obtained from gff3 file

gene.vector=as.integer(ALL.vector%in%DEG.vector) #Construct new vector with 1 for DEG and 0 for others
names(gene.vector)=ALL.vector #set names

#Calculate Probability Weighting Function
pwf<-nullp(gene.vector, ID.vector, bias.data=length.vector) #weight vector by length of gene
```

# Prepare GO term dataframe
```{r}
#talk to Hollie about why GO.terms have less gene IDs here
#erin used this to connect to KO terms, but it reduces amount of gene IDs, I think I should use the Gene.GO.IDs
#looked at Gene.GO.IDS and here we would be removing NAs which would be removing gene_ids that do not have associated GO terms, should we use the NA removed file to combine with KEGG terms or the full gene_id list that could possible have ko terms but not GO terms attached? I vote for second option
GO.annot <- subset(Annot, select=c(gene_id, Gene_ontology_IDs))
GO.annot.na <- filter(GO.annot, Gene_ontology_IDs!="NA;NA") #Remove NAs
GO.annot.na$GO_IDs <- gsub("NA;", "", GO.annot.na$Gene_ontology_IDs)  #Remove NAs
GO.annot.na$GO_IDs <- gsub(";NA", "", GO.annot.na$Gene_ontology_IDs)  #Remove NAs
splitted <- strsplit(as.character(GO.annot.na$Gene_ontology_IDs), ";") #split into multiple GO ids
GO.terms <- data.frame(v1 = rep.int(GO.annot.na$gene_id, sapply(splitted, length)), v2 = unlist(splitted)) #list all genes with each of their GO terms in a single row
colnames(GO.terms) <- c("gene_id", "GO.ID")

GO.terms$GO.ID<- as.character(GO.terms$GO.ID)
GO.terms$GO.ID <- replace_na(GO.terms$GO.ID, "unknown")
GO.terms$GO.ID <- as.factor(GO.terms$GO.ID)
GO.terms$gene_id <- as.factor(GO.terms$gene_id)
GO.terms$GO.ID <- gsub(" ", "", GO.terms$GO.ID)
GO.terms <- unique(GO.terms)
as.data.frame(GO.terms)

dim(GO.terms)
head(GO.terms, 10)

nrow(GO.terms)/length(unique(GO.terms$gene_id)) #avg GO IDs per gene
```

```{r}
#Find enriched GO terms, 
GO.wall<-goseq(pwf, ID.vector, gene2cat=Gene.GO.IDs, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)

#Find only enriched GO terms that are statistically significant at cutoff
GO.sig.trt <- GO.wall %>%
  filter(over_represented_pvalue <0.05) %>%
  arrange(., ontology)
write.csv(GO.sig.trt , file = "RAnalysis/Output/RNA-seq/GOSeq/RNASeq.GO.sig.trt.csv")

nrow(GO.sig.trt)
nrow(filter(GO.sig.trt, ontology=="BP")) #number sig BP terms = 174
nrow(filter(GO.sig.trt, ontology=="MF")) #number sig MF terms = 71
nrow(filter(GO.sig.trt, ontology=="CC")) #number sig CC terms = 23
```

## Find GOslim terms

# Run GOslim to get broader categories
```{r}
#load in generic GO database, has all of the upperlevel categories for GO terms. Ex: regulation of cell division would be under cellular regulation
slim <- getOBOCollection("http://current.geneontology.org/ontology/subsets/goslim_generic.obo") #get GO database

## filtering all of BP (do MF and CC seperately)
BP_GO <- GO.sig.trt %>%
  filter(ontology=="BP")
BPGO_collection <- GOCollection(BP_GO$category) #Make library of query terms
slims_bp <- data.frame(goSlim(BPGO_collection, slim, "BP")) #Find common parent terms to slim down our list
slims_bp$category <- row.names(slims_bp) #save rownames as category

## filtering all of MF
MF_GO <- GO.sig.trt %>%
  filter(ontology=="MF")
MFGO_collection <- GOCollection(MF_GO$category) #Make library of query terms
slims_mf <- data.frame(goSlim(MFGO_collection, slim, "MF")) #Find common parent terms to slim down our list
slims_mf$category <- row.names(slims_mf) #save rownames as category

## filtering all of CC
CC_GO <- GO.sig.trt %>%
  filter(ontology=="CC")
CCGO_collection <- GOCollection(CC_GO$category) #Make library of query terms
slims_cc <- data.frame(goSlim(CCGO_collection, slim, "CC")) #Find common parent terms to slim down our list
slims_cc$category <- row.names(slims_cc) #save rownames as category
```

# Get mapped terms, using functions from Sam White's Biostars [post](https://support.bioconductor.org/p/128407/#128409).
```{r}
#custom function from Sam White's, gets mapped ids for all of your query terms 
#Write function mappedIds to get the query terms that mapped to the slim categories
mappedIds <-
  function(df, collection, OFFSPRING) #the command to run requires a dataframe of slim terms, like slims_MF above, your list of query terms, and the offspring from the GOCollection by goSlim
  {
    map <- as.list(OFFSPRING[rownames(df)]) # Subset GOcollection offspring by the rownames of your dataframe
    mapped <- lapply(map, intersect, ids(collection)) #Find the terms that intersect between the subset made above of your query terms and the GOids from the GO collection
    df[["go_terms"]] <- vapply(unname(mapped), paste, collapse = ";", character(1L)) #Add column "go_terms" with matching terms 
    df #show resulting dataframe
  }
#Run function for MF and BP terms
BPslim <- mappedIds(slims_bp, BPGO_collection, GOBPOFFSPRING)
MFslim <- mappedIds(slims_mf, MFGO_collection, GOMFOFFSPRING)
CCslim <- mappedIds(slims_cc, CCGO_collection, GOCCOFFSPRING)
```

# Remove duplicate matches, keeping the broader umbrella term
```{r}
#filtering out duplicates, keep the largest branch that has the most GO terms

#BP
BPslim <- filter(BPslim, Count>0 & Term!="biological_process") #filter out empty slims and term "biological process"
BPsplitted <- strsplit(as.character(BPslim$go_terms), ";") #split into multiple GO ids
BPslimX <- data.frame(Term = rep.int(BPslim$Term, sapply(BPsplitted, length)), go_term = unlist(BPsplitted)) #list all
BPslimX <- merge(BPslimX, BPslim[,c(1,3:4)], by="Term") #Add back counts, term, and category info
BPslimX <- unique(setDT(BPslimX)[order(go_term, -Count)], by = "go_term") #remove duplicate offspring terms, keeping only those that appear in the larger umbrella term (larger Count number)
BPslim <- data.frame(slim_term=BPslimX$Term, slim_cat=BPslimX$category, category=BPslimX$go_term) #rename columns
head(BPslim)

#MF
MFslim <- filter(MFslim, Count>0 & Term!="molecular_function") #filter out empty slims and term "molecular function"
MFsplitted <- strsplit(as.character(MFslim$go_terms), ";") #split into multiple GO ids
MFslimX <- data.frame(Term = rep.int(MFslim$Term, sapply(MFsplitted, length)), go_term = unlist(MFsplitted)) #list all
MFslimX <- merge(MFslimX, MFslim[,c(1,3:4)], by="Term")  #Add back counts, term, and category info
MFslimX <- unique(setDT(MFslimX)[order(go_term, -Count)], by = "go_term")  #remove duplicate offspring terms, keeping only
MFslim <- data.frame(slim_term=MFslimX$Term, slim_cat=MFslimX$category, category=MFslimX$go_term) #rename columns
head(MFslim)

#CC
CCslim <- filter(CCslim, Count>0 & Term!="cellular_component") #filter out empty slims and term "molecular function"
CCsplitted <- strsplit(as.character(CCslim$go_terms), ";") #split into multiple GO ids
CCslimX <- data.frame(Term = rep.int(CCslim$Term, sapply(CCsplitted, length)), go_term = unlist(CCsplitted)) #list all
CCslimX <- merge(CCslimX, CCslim[,c(1,3:4)], by="Term")  #Add back counts, term, and category info
CCslimX <- unique(setDT(CCslimX)[order(go_term, -Count)], by = "go_term")  #remove duplicate offspring terms, keeping only
CCslim <- data.frame(slim_term=CCslimX$Term, slim_cat=CCslimX$category, category=CCslimX$go_term) #rename columns
head(CCslim)

```

# Save slim info with GO enrichment info for heatmap dataframes.
```{r}
GO.BP <- right_join(BPslim, filter(GO.sig.trt, ontology=="BP"), by="category") #add back GO enrichment info for each offspring term
GO.MF <- right_join(MFslim, filter(GO.sig.trt, ontology=="MF"), by="category") #add back GO enrichment info for each offspring term
GO.CC <- right_join(CCslim, filter(GO.sig.trt, ontology=="CC"), by="category") #add back GO enrichment info for each offspring term
```


## Make heatmap
```{r}
BPplot <- GO.BP %>% mutate(term = fct_reorder(term, -over_represented_pvalue)) %>%
    ggplot(aes(x = ontology, y = term)) + 
    geom_tile(aes(fill=over_represented_pvalue, width = 1)) + 
      scale_y_discrete(position = "right") +
      facet_grid(slim_term~ ., scales = "free_y", labeller = label_wrap_gen(width = 10, multi_line = TRUE))+
      theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
      strip.text.y.left = element_text(angle=0, size = 11, face = "bold"),
      strip.text.x = element_text(size = 12, face = "bold"),
      axis.title = element_blank(),
      axis.text = element_text(size = 12), legend.title = element_text(size = 12), legend.text =     
      element_text(size = 11))
MFplot <- GO.MF %>% mutate(term = fct_reorder(term, -over_represented_pvalue)) %>% 
    ggplot(aes(x = ontology, y = term)) + 
    geom_tile(aes(fill=over_represented_pvalue, width = 1)) + 
      scale_y_discrete(position = "right") +
      facet_grid(slim_term~ ., scales = "free_y", labeller = label_wrap_gen(width = 10, multi_line = TRUE))+
      theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
      strip.text.y.left = element_text(angle=0, size = 11, face = "bold"),
      strip.text.x = element_text(size = 12, face = "bold"),
      axis.title = element_blank(),
      axis.text = element_text(size = 12), legend.title = element_text(size = 12), legend.text =
      element_text(size = 11))
fig5 <- BPplot + MFplot
ggsave("RAnalysis/Output/RNA-seq/GOSeq/DEG_heatmap_GO_terms.pdf", fig5, width = 30, height = 30, units = c("in"))
```

## Make supplemental table summarizing GO enrichment
```{r}
GO.enrichment.dat <- bind_rows(GO.BP, GO.MF, GO.CC)
head(GO.enrichment.dat)

#Make dataframe of GO results for clustering and heatmap. 
#add gene_IDs. To get gene_IDs we will merge with the GO.terms DF.
GOgenes <- data.frame(gene_id=GO.terms$gene_id, category=GO.terms$GO.ID) 
GOgenes$gene_id <- as.character(GOgenes$gene_id) #make gene ID a character so we can collapse our many near-identical columns

GO.enrichment.summary  <- left_join(GO.enrichment.dat, GOgenes, by="category" ) #join the DFs

GO.enrichment.summary <- GO.enrichment.summary %>% #collapse and have gene IDs for a particular term in a single row as a comma-sep list. 
  group_by(slim_term, slim_cat, category, over_represented_pvalue, under_represented_pvalue, numDEInCat, numInCat, term, ontology) %>%
  summarise(genes = toString(gene_id)) %>% #rename collapsed gene_ID column "gene"
  ungroup()

write.csv(GO.enrichment.summary, 'RAnalysis/Output/RNA-seq/GOSeq/GO.enrichment.summary.table.csv') 
```

## KEGG enrichment analysis
## Obtained KEGG ontology terms by using KofamScan in command-line; see step 3 in E. Chille lab notebook https://github.com/echille/E.-Chille-Open-Lab-Notebook/blob/master/_posts/2020-10-08-M-capitata-functional-annotation-pipeline.md for instructions. 
## If run into issues with downloading KofamScan software, etc.; see https://github.com/Putnam-Lab/Lab_Management/issues/21

# Load KO -- gene mapping info
```{r}
#need to have nomenclature for gene IDs match between the annot and KFS.KO files, right now there are 2 formats in Pver_gene_annotation_file.txt

#Pver_gene_g#
#Pver_novel_gene_#_5de57afd

#There are 3 formats in the Pver_KO_annot.tsv.gz

#Pver_g1.t2
#Pver_novel_model_1_5de57afd
#Pver_split_gene_g408-g408.t1-m18

#need to remove '_split_' (completed by dmbp)
#need to add a '_gene_' before the 'g#.t#' int he KFS.KO file to match annot and need to remove '.t#' from ID (completed by dmbp)

#goal is to check functional annotation with gff3 and KOfamscan output nomenclature for gene IDs across all files 
#step 1: confirm names of columns that contain gene IDs (manually changed column names to gene_IDs)
#step 2: find the inconsistencies between the files (ex: identify total number of expected genes; row number in the gff) sanity check with NCBI or manuscript total number of genes
        #length (unique) genes; nrow is the function from all files 
        #somehow organize gene ids into categories (ex: Pver_gene; Pver_split; Pver_novel)
        #some sort of match or total table
        #look at raw data for syntax of the names to find general inconsistencies 
        #take gff3 and functional annotation and full_join those; repeat with any subsequent files you want to join


KFS.KO$gene_id <- gsub("augustus.", "", KFS.KO$gene_id)
KFS.KO$gene_id <- gsub(".t[0-9]", "", KFS.KO$gene_id)
KFS.KO$gene_id <- gsub("Pver_split_", "Pver_", KFS.KO$gene_id)
KFS.KO$gene_id <- gsub("Pver_", "Pver_gene_", KFS.KO$gene_id)
head(KFS.KO)
tail(KFS.KO)

#ask Hollie question here about joining, what we need for moving forward
#bind all KO results
KO.terms <- left_join(Annot, KFS.KO)
KO.terms <- KO.terms[, c(2,14)]
KO.terms.unique <- unique(KO.terms$ko)
str(KO.terms)
head(KO.terms)

colnames(KO.terms) <- c("gene_id", "KO.ID")
#Bind KO and GO references
GOKO.terms <- left_join(Gene.GO.IDs, KO.terms)
length(unique(Gene.GO.IDs$gene_id)) #sanity check here when I had GO.terms combining with KO terms showed 23,791 gene IDs because NAs from the GO.terms were removed which removed some gene_ids, I think we should use full list of gene_ids in the Gene.GO.IDs because some may have corresponging Kegg terms? See line 160 for more information
#when I use Gene.GO.IDs there is the correct gene id length of 27,439
```


# Perform KEGG enrichment with GOSeq package
```{r}
#Perform goseq
KOwall <- goseq(pwf, GOref$gene_id, gene2cat=GOKO.terms, test.cats=c("KEGG"), method="Wallenius", use_genes_without_cat=TRUE)

```

# Replace NAs with "KEGG" and extract KO terms from results
```{r}
#Cluster1
KO.05<-KOwall$category[KOwall$over_represented_pvalue<.05]
KO.05<-data.frame(KO.05)
colnames(KO.05) <- c("category")
KO.05 <- merge(KO.05, KOwall.C1, by="category")
KO.05$ontology <- replace_na(KO.05$ontology, "KEGG")
KO.05 <- filter(KO.05, ontology=="KEGG")
KO.05 <- KO.05[order(KO.05$ontology, KO.05$over_represented_pvalue, -KO.05$numDEInCat),]
KO.05$term <- as.factor(KO.05$term)
nrow(KO.05)

```

# Add KO definitions
```{r}
#Prep definition data
KFS.KO.def <- subset(KFS.KO.orig, select=c("#","KO", "KO definition"))
colnames(KFS.KO.def) <- c("sig","category", "term")
KFS.KO.def <- filter(KFS.KO.def, sig=="*")
KFS.KO.def <- KFS.KO.def[,c(2:3)]
#Merge with KEGG outp
KO.05 <- unique(left_join(C1.KO.05[,-6], KFS.KO.def, by=c("category")))

```

# Write output KEGG enrichment files
```{r}
write.csv(C1.KO.05, file = "RAnalysis/Output/RNA-seq/GOSeq/KO.05.csv")

```
