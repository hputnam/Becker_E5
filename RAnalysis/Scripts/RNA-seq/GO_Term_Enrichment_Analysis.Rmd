---
title: "GO_Term_Enrichment_Analysis"
author: "echille"
edited by: "daniellembecker"
date: "6/3/2021"
output: html_document
---

# Molecular Underpinnings Chronic Nutrient Enrichment Project

## RNAseq Gene Ontology (GO) Enrichment Analysis 
## Previous steps include RNAseq workflow in Bioinformatics>RNAseq>RNAseq workflow and Differential Gene Expression statistical analysis in RAnalysis>Scripts>RNAseq_Differential_Gene_Expression to make DEG statistical data sheet

### Set up workspace

Load necessary libraries
```{r}
library(goseq)
library(tidyverse)
library(GSEABase)
library(data.table)
library(ggplot2)
library(cowplot)
library(patchwork)
library(ape)
```

Import the data files 
```{r}
#treatment information
treatmentinfo <- read.csv("../../Data/RNA-seq/metadata.RNAseq.csv", header = TRUE, sep = ",")
str(treatmentinfo)
head(treatmentinfo)

#DEG significant results
DEG.res <- read.csv("../../Output/RNA-seq/DEG/DEGSeq2.sig.results.csv")[,-1]
nrow(DEG.res)
DEG.res$gene_id <-  gsub("_gene","",DEG.res$gene_id) #remove extra characters
  

#transcript annotations
Annot <- read_tsv( "../../Genome/Pver_gene_annotation_file.txt", col_names = TRUE) #biological annotation information
colnames(Annot)[2] <- "gene_id"
GO.data <- Annot[,c(2,13)] #select gene names and GO IDs
splitted <- strsplit(as.character(GO.data$Gene_ontology_IDs), "; ") #split into multiple GO IDs
Gene.GO.IDs <- data.frame(v1 = rep.int(GO.data$gene_id, sapply(splitted, length)), v2 = unlist(splitted)) #list all genes with each of their GO terms in a single row 
colnames(Gene.GO.IDs) <- c("gene_id", "GO.IDs") #rename columns
Gene.GO.IDs$gene_id <-  gsub("_gene","",Gene.GO.IDs$gene_id) #remove extra characters
Gene.GO.IDs$GO.IDs <- as.character(Gene.GO.IDs$GO.IDs) #make IDs into characters

#structural annotation file needed to calculate the length by stop position - start position 
#bring in the gene specific gff3 and pull out gene id 
length.struct.annot <- read.csv("../../Genome/Pver_genome_assembly_v1.0.gene.gff3", header = FALSE, sep="", skip = 1)
length(unique(length.struct.annot$V9)) # 27439
colnames(length.struct.annot) <- c("prot", "Predict", "id", "start","stop", "pos1", "pos2","pos3", "attr")
length.struct.annot$length <- length.struct.annot$stop - length.struct.annot$start
length.struct.annot$gene_id <-  length.struct.annot$attr
length.struct.annot$gene_id <-  gsub(";.*","",length.struct.annot$gene_id) #remove extra characters
length.struct.annot$gene_id <- gsub("ID=","",length.struct.annot$gene_id) #remove extra characters
length.struct.annot$gene_id <-  gsub("_gene","",length.struct.annot$gene_id) #remove extra characters
  
```

# Set ID and gene length vectors, and make a binary matrix indicating which genes are differentially expressed. These are used as input to nullp, which for calculates a Probability Weighting Function for each set of DEGs.
```{r}
#Make ID and length vectors
#go.ref <- unique(go.ref)
#dim(go.ref)
DEG.vector <- DEG.res$gene_id #the enrichment test list
ALL.vector <- length.struct.annot$gene_id
ID.vector <- length.struct.annot$gene_id #id obtained from gff3 file
length.vector <- length.struct.annot$length #length obtained from gff3 file

gene.vector=as.integer(ALL.vector%in%DEG.vector) #Construct new vector with 1 for DEG and 0 for others
names(gene.vector)=ALL.vector #set names

#Calculate Probability Weighting Function
DMG.pwf<-nullp(gene.vector, ID.vector, bias.data=length.vector) #weight vector by length of gene

#Find enriched GO terms, 
GO.wall<-goseq(DMG.pwf, ID.vector, gene2cat=Gene.GO.IDs, test.cats=c("GO:CC", "GO:BP", "GO:MF"), method="Wallenius", use_genes_without_cat=TRUE)

GO.sig.trt <- GO.wall %>%
  filter(over_represented_pvalue <0.05) %>%
  arrange(., ontology)
#write.csv(GO.sig.trt , file = "../../Output/RNASeq.GO.sig.trt.csv")

nrow(GO.sig.trt)
nrow(filter(GO.sig.trt, ontology=="BP")) #number sig BP terms
nrow(filter(GO.sig.trt, ontology=="MF")) #number sig MF terms
nrow(filter(GO.sig.trt, ontology=="CC")) #number sig CC terms


```


# Run GOslim to get broader categories
```{r}
#load in generic GO database, has all of the upperlevel categories for GO terms. Ex: regulation of cell division would be under cellular regulation
slim <- getOBOCollection("http://current.geneontology.org/ontology/subsets/goslim_generic.obo") #get GO database

## filtering all of BP (do MF and CC seperately)
BP_GO <- GO.sig.trt %>%
  filter(ontology=="BP")
BPGO_collection <- GOCollection(BP_GO$category) #Make library of query terms
slims_bp <- data.frame(goSlim(BPGO_collection, slim, "BP")) #Find common parent terms to slim down our list
slims_bp$category <- row.names(slims_bp) #save rownames as category

## filtering all of MF
MF_GO <- GO.sig.trt %>%
  filter(ontology=="MF")
MFGO_collection <- GOCollection(MF_GO$category) #Make library of query terms
slims_mf <- data.frame(goSlim(MFGO_collection, slim, "MF")) #Find common parent terms to slim down our list
slims_mf$category <- row.names(slims_mf) #save rownames as category

## filtering all of CC
CC_GO <- GO.sig.trt %>%
  filter(ontology=="CC")
CCGO_collection <- GOCollection(CC_GO$category) #Make library of query terms
slims_cc <- data.frame(goSlim(CCGO_collection, slim, "CC")) #Find common parent terms to slim down our list
slims_cc$category <- row.names(slims_cc) #save rownames as category
```

# Get mapped terms, using functions from Sam White's Biostars [post](https://support.bioconductor.org/p/128407/#128409).
```{r}
#custom function from Sam White's, gets mapped ids for all of your query terms 
#Write function mappedIds to get the query terms that mapped to the slim categories
mappedIds <-
  function(df, collection, OFFSPRING) #the command to run requires a dataframe of slim terms, like slims_MF above, your list of query terms, and the offspring from the GOCollection by goSlim
  {
    map <- as.list(OFFSPRING[rownames(df)]) # Subset GOcollection offspring by the rownames of your dataframe
    mapped <- lapply(map, intersect, ids(collection)) #Find the terms that intersect between the subset made above of your query terms and the GOids from the GO collection
    df[["go_terms"]] <- vapply(unname(mapped), paste, collapse = ";", character(1L)) #Add column "go_terms" with matching terms 
    df #show resulting dataframe
  }
#Run function for MF and BP terms
BPslim <- mappedIds(slims_bp, BPGO_collection, GOBPOFFSPRING)
MFslim <- mappedIds(slims_mf, MFGO_collection, GOMFOFFSPRING)
CCslim <- mappedIds(slims_cc, CCGO_collection, GOCCOFFSPRING)
```

# Remove duplicate matches, keeping the broader umbrella term
```{r}
#filtering out duplicates, keep the largest branch that has the most GO terms

#BP
BPslim <- filter(BPslim, Count>0 & Term!="biological_process") #filter out empty slims and term "biological process"
BPsplitted <- strsplit(as.character(BPslim$go_terms), ";") #split into multiple GO ids
BPslimX <- data.frame(Term = rep.int(BPslim$Term, sapply(BPsplitted, length)), go_term = unlist(BPsplitted)) #list all
BPslimX <- merge(BPslimX, BPslim[,c(1,3:4)], by="Term") #Add back counts, term, and category info
BPslimX <- unique(setDT(BPslimX)[order(go_term, -Count)], by = "go_term") #remove duplicate offspring terms, keeping only those that appear in the larger umbrella term (larger Count number)
BPslim <- data.frame(slim_term=BPslimX$Term, slim_cat=BPslimX$category, category=BPslimX$go_term) #rename columns
head(BPslim)

#MF
MFslim <- filter(MFslim, Count>0 & Term!="molecular_function") #filter out empty slims and term "molecular function"
MFsplitted <- strsplit(as.character(MFslim$go_terms), ";") #split into multiple GO ids
MFslimX <- data.frame(Term = rep.int(MFslim$Term, sapply(MFsplitted, length)), go_term = unlist(MFsplitted)) #list all
MFslimX <- merge(MFslimX, MFslim[,c(1,3:4)], by="Term")  #Add back counts, term, and category info
MFslimX <- unique(setDT(MFslimX)[order(go_term, -Count)], by = "go_term")  #remove duplicate offspring terms, keeping only
MFslim <- data.frame(slim_term=MFslimX$Term, slim_cat=MFslimX$category, category=MFslimX$go_term) #rename columns
head(MFslim)

#CC
CCslim <- filter(CCslim, Count>0 & Term!="cellular_component") #filter out empty slims and term "molecular function"
CCsplitted <- strsplit(as.character(CCslim$go_terms), ";") #split into multiple GO ids
CCslimX <- data.frame(Term = rep.int(CCslim$Term, sapply(CCsplitted, length)), go_term = unlist(CCsplitted)) #list all
CCslimX <- merge(CCslimX, CCslim[,c(1,3:4)], by="Term")  #Add back counts, term, and category info
CCslimX <- unique(setDT(CCslimX)[order(go_term, -Count)], by = "go_term")  #remove duplicate offspring terms, keeping only
CCslim <- data.frame(slim_term=CCslimX$Term, slim_cat=CCslimX$category, category=CCslimX$go_term) #rename columns
head(CCslim)

```

# Save slim info with GO enrichment info for heatmap dataframes.
```{r}
GO.BP <- right_join(BPslim, filter(GO.sig.trt, ontology=="BP"), by="category") #add back GO enrichment info for each offspring term
GO.MF <- right_join(MFslim, filter(GO.sig.trt, ontology=="MF"), by="category") #add back GO enrichment info for each offspring term
GO.CC <- right_join(CCslim, filter(GO.sig.trt, ontology=="CC"), by="category") #add back GO enrichment info for each offspring term
```


## Make heatmap
```{r}
BPplot <- GO.BP %>% mutate(term = fct_reorder(term, -over_represented_pvalue)) %>%
    ggplot(aes(x = ontology, y = term)) + 
    geom_tile(aes(fill=over_represented_pvalue, width = 1)) + 
      scale_y_discrete(position = "right") +
      facet_grid(slim_term~ ., scales = "free_y", labeller = label_wrap_gen(width = 10, multi_line = TRUE))+
      theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
      strip.text.y.left = element_text(angle=0, size = 11, face = "bold"),
      strip.text.x = element_text(size = 12, face = "bold"),
      axis.title = element_blank(),
      axis.text = element_text(size = 12), legend.title = element_text(size = 12), legend.text =     
      element_text(size = 11))
MFplot <- GO.MF %>% mutate(term = fct_reorder(term, -over_represented_pvalue)) %>% 
    ggplot(aes(x = ontology, y = term)) + 
    geom_tile(aes(fill=over_represented_pvalue, width = 1)) + 
      scale_y_discrete(position = "right") +
      facet_grid(slim_term~ ., scales = "free_y", labeller = label_wrap_gen(width = 10, multi_line = TRUE))+
      theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
      panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
      strip.text.y.left = element_text(angle=0, size = 11, face = "bold"),
      strip.text.x = element_text(size = 12, face = "bold"),
      axis.title = element_blank(),
      axis.text = element_text(size = 12), legend.title = element_text(size = 12), legend.text =
      element_text(size = 11))
fig5 <- BPplot + MFplot
ggsave("../../Output/DEG_heatmap_GO_terms.pdf", fig5, width = 30, height = 20, units = c("in"))

```

## Make supplemental table summarizing GO enrichment
```{r}
GO.enrichment.summary.table <- bind_rows(GO.BP, GO.MF, GO.CC)
head(GO.enrichment.summary.table)
write.csv(GO.enrichment.summary.table, '../../Output/GO.enrichment.summary.table.ontology.csv') 
```





## KEGG enrichment analysis
## Obtained KEGG ontology terms by using KofamScan in command-line; see step 3 in E. Chille lab notebook https://github.com/echille/E.-Chille-Open-Lab-Notebook/blob/master/_posts/2020-10-08-M-capitata-functional-annotation-pipeline.md for instructions. 
## If run into issues with downloading KofamScan software, etc.; see https://github.com/Putnam-Lab/Lab_Management/issues/21

# Load KO -- gene mapping info
```{r}
#Load in and prep KofamScan search results
KFS.KO.orig <- read_tsv("../../Genome/KEGG-ontology/Pver_KO_annot.tsv.gz", col_names = TRUE)
KFS.KO <- KFS.KO.orig[-1,-1]
KFS.KO <- KFS.KO[, c(1,2,5)]
colnames(KFS.KO) <- c("gene_id", "ko", "sig")
KFS.KO <- KFS.KO[,c(1:2)]
#KFS.KO$gene_id <- gsub("augustus.", "", KFS.KO$gene_id)
KFS.KO$gene_id <- gsub(".t1", "", KFS.KO$gene_id)
head(KFS.KO)
tail(KFS.KO)

#bind all KO results
KO.terms <- bind_rows(Annot, KFS.KO)
KO.terms <- unique(KO.terms)
str(KO.terms)
head(KO.terms)
colnames(KO.terms) <- c("gene_id", "GO.ID")
#Bind KO and GO references
GOKO.terms <- bind_rows(GO.terms, KO.terms)
```

# Obtain KO terms for each cluster of DEGs to be used for the KEGG Mapper [(link)](https://www.genome.jp/kegg/mapper.html)
```{r}
koC1 <- filter(KO.terms, gene_id%in%clust1$gene_id) #Filter for gene IDs in cluster1
koC2 <- filter(KO.terms, gene_id%in%clust2$gene_id) #Filter for gene IDs in cluster2
dim(koC1)
dim(koC2)
write.table(koC1, "5-Planula-GO-Enrichment-Analysis/Output/koC1.KEGG_mapper_input.txt", quote=FALSE,col.names=FALSE,row.names=FALSE,sep="\t") #TO BE USED FOR KEGG Mapper https://www.genome.jp/kegg/mapper.html.
write.table(koC2, "5-Planula-GO-Enrichment-Analysis/Output/koC2.KEGG_mapper_input.txt", quote=FALSE,col.names=FALSE,row.names=FALSE,sep="\t") #TO BE USED FOR KEGG Mapper https://www.genome.jp/kegg/mapper.html.
```

# Perform KEGG enrichment with GOSeq package
```{r}
#Perform goseq
KOwall.C1 <- goseq(pwf.C1, GOref$gene_id, gene2cat=GO.terms, test.cats=c("KEGG"), method="Wallenius", use_genes_without_cat=TRUE)
KOwall.C2 <- goseq(pwf.C2, GOref$gene_id, gene2cat=GO.terms, test.cats=c("KEGG"), method="Wallenius", use_genes_without_cat=TRUE)
```

# Replace NAs with "KEGG" and extract KO terms from results
```{r}
#Cluster1
C1.KO.05<-KOwall.C1$category[KOwall.C1$over_represented_pvalue<.05]
C1.KO.05<-data.frame(C1.KO.05)
colnames(C1.KO.05) <- c("category")
C1.KO.05 <- merge(C1.KO.05, KOwall.C1, by="category")
C1.KO.05$ontology <- replace_na(C1.KO.05$ontology, "KEGG")
C1.KO.05 <- filter(C1.KO.05, ontology=="KEGG")
C1.KO.05 <- C1.KO.05[order(C1.KO.05$ontology, C1.KO.05$over_represented_pvalue, -C1.KO.05$numDEInCat),]
C1.KO.05$term <- as.factor(C1.KO.05$term)
nrow(C1.KO.05)
#Cluster2
C2.KO.05<-KOwall.C2$category[KOwall.C2$over_represented_pvalue<.05]
C2.KO.05<-data.frame(C2.KO.05)
colnames(C2.KO.05) <- c("category")
C2.KO.05 <- merge(C2.KO.05, KOwall.C2, by="category")
C2.KO.05$ontology <- replace_na(C2.KO.05$ontology, "KEGG")
C2.KO.05 <- filter(C2.KO.05, ontology=="KEGG")
C2.KO.05 <- C2.KO.05[order(C2.KO.05$ontology, C2.KO.05$over_represented_pvalue, -C2.KO.05$numDEInCat),]
C2.KO.05$term <- as.factor(C2.KO.05$term)
nrow(C2.KO.05)
```

# Add KO definitions
```{r}
#Prep definition data
KFS.KO.def <- subset(KFS.KO.orig, select=c("#","KO", "KO definition"))
colnames(KFS.KO.def) <- c("sig","category", "term")
KFS.KO.def <- filter(KFS.KO.def, sig=="*")
KFS.KO.def <- KFS.KO.def[,c(2:3)]
#Merge with KEGG output
C1.KO.05 <- unique(left_join(C1.KO.05[,-6], KFS.KO.def, by=c("category")))
C2.KO.05 <- unique(left_join(C2.KO.05[,-6], KFS.KO.def, by=c("category")))
```

# Write output KEGG enrichment files
```{r}
write.csv(C1.KO.05, file = "5-Planula-GO-Enrichment-Analysis/Output/KO.05.C1.csv")
write.csv(C2.KO.05, file = "5-Planula-GO-Enrichment-Analysis/Output/KO.05.C2.csv")
```
